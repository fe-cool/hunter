{
    "componentChunkName": "component---src-templates-issues-tsx",
    "path": "/issues/47",
    "result": {"data":{"issuesJson":{"id":"ab4f5d9b-8e47-5733-b0a0-124cec8e1235","title":"get与post请求的区别是？","number":47,"bodyHTML":"\n<h3 dir=\"auto\">要回答的问题</h3>\n\n<p dir=\"auto\"><code class=\"notranslate\">get</code>与<code class=\"notranslate\">post</code>都是常见的<code class=\"notranslate\">HTTP</code>请求方法，请从以下角度回答他们的区别：</p>\n<ol dir=\"auto\">\n<li>语义的区别</li>\n<li>应用场景的区别</li>\n<li>请求url、请求头、请求体的区别</li>\n<li>其他方面（比如安全、长度限制...）的区别</li>\n</ol>\n<h3 dir=\"auto\">最佳答案评选标准</h3>\n \n<p dir=\"auto\">按如上所列角度全面、详细的回答</p>\n<h2 dir=\"auto\">最佳答案</h2>\n<p dir=\"auto\"><a href=\"https://github.com/BetaSu/fe-hunter/issues/47#issuecomment-1090104352\" data-hovercard-type=\"issue\" data-hovercard-url=\"/BetaSu/fe-hunter/issues/47/hovercard\">xiaxiangfeng的回答</a></p>\n<h3 dir=\"auto\">答题同学须知</h3>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\">答题规范：请在<code class=\"notranslate\">一次评论</code>中完成作答，后续修改也请编辑该评论，而不是追加新的评论</p>\n</li>\n<li>\n<p dir=\"auto\">评选标准：最佳答案由<code class=\"notranslate\">围观同学</code>的 <g-emoji class=\"g-emoji\" alias=\"+1\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png\">👍</g-emoji> 和<a href=\"https://github.com/BetaSu\">卡颂</a>共同决定</p>\n</li>\n<li>\n<p dir=\"auto\">评选时间：一般是问题发布24小时后评选，如果问题发布当天回答数较少，问题悬赏金额可能增加，同时悬赏时间也会增加</p>\n</li>\n</ul>\n<h3 dir=\"auto\">围观同学须知</h3>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\">对于你满意的答案，请不要吝惜你的 <g-emoji class=\"g-emoji\" alias=\"+1\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png\">👍</g-emoji>，这是评选<strong>最佳答案</strong>的依据</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">非答题的评论</code>会被删除，问题相关讨论请在<a href=\"https://github.com/BetaSu/fe-hunter\">赏金猎人群</a>中进行</p>\n</li>\n</ul>","updatedAt":"2022-04-08T01:58:29Z","upvoteCount":null,"author":{"login":"BetaSu","avatarUrl":"https://avatars.githubusercontent.com/u/15828041?u=3b08cdf9f9b49dbead9ffb020a94d925904d2b74&v=4","url":"https://github.com/BetaSu"},"category":null,"labels":{"edges":[{"node":{"name":"基础","color":"1e88e5"}},{"node":{"name":"网络","color":"FBCA04"}}]},"comments":{"edges":[{"node":{"id":"IC_kwDOHCfdf85A8zuS","bodyHTML":"<ul dir=\"auto\">\n<li>用途：get 一般用于<strong>查询操作获取数据</strong>，post 一般用于<strong>用户提交数据。</strong></li>\n<li>携带数据的方式：get 请求的参数<code class=\"notranslate\">params</code>会拼接在url上，用<code class=\"notranslate\">?</code>分割，多个参数之间用<code class=\"notranslate\">&amp;</code>连接； post请求会将参数/数据放在http请求中的<code class=\"notranslate\">body</code>里</li>\n<li>可携带数据的大小：get 请求参数有长度限制（受限于url长度），而post可携带的数据体积就更大了（无限制）。</li>\n<li>安全：Post相比于Get更安全，get参数会暴露在url上，<strong>get的参数会保留在浏览器历史记录中。post参数不会保留在浏览器历史记录中</strong></li>\n</ul>","author":{"login":"Travelguest","avatarUrl":"https://avatars.githubusercontent.com/u/42471249?u=da42abea217ddf6f316e2b887c7e2d270566f854&v=4","url":"https://github.com/Travelguest"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85A8zux","bodyHTML":"<p dir=\"auto\">1、get是从服务器中获取数据，post是向服务器提交数据。<br>\n2、get请求具有幂等性，post不具有。<br>\n3、get的传参在url后面，post传参是在form表单中<br>\n4、get相对不安全，参数全部在url中，且可被浏览器记录在历史中。post相对较安全，浏览器不会保留。<br>\n5、get传输数据少（浏览器对url设置了长度上限）。<br>\n6、get有一个tcp请求，post有两个（100 continue，200 ok）</p>","author":{"login":"Cloudkkk","avatarUrl":"https://avatars.githubusercontent.com/u/58101940?u=cb5bfbe209abbe508c94da365110653b6541655c&v=4","url":"https://github.com/Cloudkkk"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85A8z4x","bodyHTML":"<h2 dir=\"auto\">常见回答</h2>\n<ol dir=\"auto\">\n<li>参数传递方式：Get 使用 URL 或 Cookie 传参，而 Post 将数据放在 body 中</li>\n<li>数据传输大小：Get 的 URL 会有长度上的限制，则 Post 的数据则可以非常大</li>\n<li>安全问题：Post 比 Get 安全，因为数据在地址栏上不可见，GET 方式请求的数据会被浏览器缓存起来，因此有安全问题</li>\n</ol>\n<h2 dir=\"auto\">最本质的区别</h2>\n<p dir=\"auto\">基于 http 协议进行请求， 其实 GET 和 POST 无区别，就像高速公路上不同车型的车，同样是运输信息，容量、方式有所区分； 请求时的方式不同， 都可以携带请求体， 也可以在 URL 带参数<br>\n区别来自于浏览器对 URL 长度的限制， 请求体大小来源于服务器的限制</p>\n<h2 dir=\"auto\">语义的区别</h2>\n<p dir=\"auto\">GET 是获取， POST 是提交<br>\nGet 是用来从服务器上获得数据，而 post 是用来向服务器上传递数据</p>","author":{"login":"c0dedance","avatarUrl":"https://avatars.githubusercontent.com/u/38075730?v=4","url":"https://github.com/c0dedance"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85A99cR","bodyHTML":"<table role=\"table\">\n<thead>\n<tr>\n<th align=\"center\">分类 <g-emoji class=\"g-emoji\" alias=\"rocket\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f680.png\">🚀</g-emoji></th>\n<th align=\"left\">GET请求</th>\n<th align=\"left\">POST请求</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">语义</td>\n<td align=\"left\">用于从服务器获取数据</td>\n<td align=\"left\">用于向服务器上传数据</td>\n</tr>\n<tr>\n<td align=\"center\">回退</td>\n<td align=\"left\">可回退、回退无害</td>\n<td align=\"left\">会再次提交</td>\n</tr>\n<tr>\n<td align=\"center\">编码</td>\n<td align=\"left\">URL编码</td>\n<td align=\"left\">多种编码格式</td>\n</tr>\n<tr>\n<td align=\"center\">参数</td>\n<td align=\"left\">长度有限、只支持ASCII、(广义去讲：浏览器：2k个字节、服务器：64K)、附带在URL中</td>\n<td align=\"left\">长度不限制，任意数据格式、放在body体</td>\n</tr>\n<tr>\n<td align=\"center\">缓存</td>\n<td align=\"left\">主动缓存、幂等</td>\n<td align=\"left\">手动设置 、非幂等</td>\n</tr>\n<tr>\n<td align=\"center\">书签</td>\n<td align=\"left\">可以</td>\n<td align=\"left\">不可以</td>\n</tr>\n<tr>\n<td align=\"center\">场景</td>\n<td align=\"left\">查询</td>\n<td align=\"left\">新增、修改</td>\n</tr>\n<tr>\n<td align=\"center\">协议</td>\n<td align=\"left\">TCP</td>\n<td align=\"left\">TCP</td>\n</tr>\n<tr>\n<td align=\"center\">协议包个数</td>\n<td align=\"left\">只有一个</td>\n<td align=\"left\">两个(先发送header服务器响应100，然后在发送data)</td>\n</tr>\n<tr>\n<td align=\"center\">安全</td>\n<td align=\"left\">不安全(参数都在URL上)</td>\n<td align=\"left\">相对安全</td>\n</tr>\n<tr>\n<td align=\"center\">总结</td>\n<td align=\"left\">本质都是 TCP 链接，并无区别。但是由于 HTTP 的规定以及浏览器/服务器的限制，导致它们在应用过程中有所不同</td>\n<td align=\"left\"></td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">PS： 其实最有争议的问题是http请求包的问题，POST请求在不同的实现中请求包也是不同，只是大多数的实现中会发送两个包，而不是所有的，比如火狐、从标准上对比来讲的话POST发送两个请求包这个并不成立，只是实现的一种方式而已</p>\n<p dir=\"auto\">最后这一点、卡哥可以展开给大家说说，这边我感觉理解的也是一直半解！</p>","author":{"login":"lkzwc","avatarUrl":"https://avatars.githubusercontent.com/u/84896877?u=f15173a1dcf50be6cecdfb59a70b8a0a8c624176&v=4","url":"https://github.com/lkzwc"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85A-awg","bodyHTML":"<h1 dir=\"auto\">语义的区别</h1>\n<ul dir=\"auto\">\n<li>GET ：获取资源，常用于读取或下载资源</li>\n<li>POST ：用于将实体（body）提交到指定的资源，通常导致状态或服务器上的副作用的更改</li>\n</ul>\n<h1 dir=\"auto\">应用场景的区别</h1>\n<p dir=\"auto\">以下情况使用 GET:</p>\n<ul dir=\"auto\">\n<li>交互更像是一个问题（即，它是一种安全操作，例如查询、读取操作或查找）</li>\n<li>请求中的 URL 可以被手动输入</li>\n<li>请求中的 URL 可以被存在书签里，或者历史里，或者快速拨号里面，或者分享给别人</li>\n<li>请求中的 URL 是可以被搜索引擎收录的</li>\n<li>带云压缩的浏览器，比如 Opera mini/Turbo 2, 只有 GET 才能在服务器端被预取的</li>\n<li>请求中的 URL 可以被缓存</li>\n</ul>\n<p dir=\"auto\">以下情况下使用 POST：</p>\n<ul dir=\"auto\">\n<li>交互更像是一个命令，或者<br>\n交互以用户可以感知的方式改变资源的状态（例如，订阅服务），或者用户应对交互的结果负责</li>\n</ul>\n<h1 dir=\"auto\">请求 url、请求头、请求体的区别</h1>\n<p dir=\"auto\">get:</p>\n<ul dir=\"auto\">\n<li>URL 的最大长度是 2048 个字符；只允许 ASCII 字符</li>\n<li>W3C 的标准 Get 不用 body；RFC 的标准 GET 可以携带 Body</li>\n</ul>\n<p dir=\"auto\">post:</p>\n<ul dir=\"auto\">\n<li>URL 数据长度无限制</li>\n</ul>\n<h1 dir=\"auto\">GET 与 POST 的本质区别有两点</h1>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\">请求行不同：</p>\n<ul dir=\"auto\">\n<li>GET：GET /uri HTTP/1.1</li>\n<li>POST：POST /uri HTTP/1.1</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\">对服务器资源的操作不同：</p>\n<ul dir=\"auto\">\n<li>GET：表示从服务器获取资源</li>\n<li>POST：向指定的服务器资源提交数据（通常导致状态或服务器上的副作用的更改）</li>\n</ul>\n</li>\n</ul>\n<h1 dir=\"auto\">其他</h1>\n<table role=\"table\">\n<thead>\n<tr>\n<th></th>\n<th>GET</th>\n<th>POST</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>后退按钮/刷新</td>\n<td>无害</td>\n<td>数据会被重新提交</td>\n</tr>\n<tr>\n<td>书签</td>\n<td>可收藏为书签</td>\n<td>不可收藏为书签</td>\n</tr>\n<tr>\n<td>缓存</td>\n<td>能被缓存</td>\n<td>不能缓存</td>\n</tr>\n<tr>\n<td>编码类型</td>\n<td>application/x-www-form-urlencoded</td>\n<td>application/x-www-form-urlencoded 或 multipart/form-data。</td>\n</tr>\n<tr>\n<td>历史</td>\n<td>参数保留在浏览器历史中</td>\n<td>参数不会保存在浏览器历史中</td>\n</tr>\n<tr>\n<td>对数据长度的限制</td>\n<td>URL 的最大长度是 2048 个字符</td>\n<td>无限制</td>\n</tr>\n<tr>\n<td>对数据类型的限制</td>\n<td>只允许 ASCII 字符</td>\n<td>没有限制。也允许二进制数据</td>\n</tr>\n<tr>\n<td>安全性</td>\n<td>安全性较差，因为所发送的数据是 URL 的一部分。</td>\n<td>更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中</td>\n</tr>\n<tr>\n<td>可见性</td>\n<td>数据在 URL 中对所有人都是可见的</td>\n<td>更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">ps: RFC 中 100 Continue 并不是 POST Method 中的一个步骤,并且也不仅仅只能用于 POST method</p>","author":{"login":"xiaxiangfeng","avatarUrl":"https://avatars.githubusercontent.com/u/2898403?u=042f27ba9a3d648754c472c545e595211861633a&v=4","url":"https://github.com/xiaxiangfeng"},"replies":null}}]}}},"pageContext":{"number":47,"previous":{"title":"虚拟DOM的意义是什么？","number":46},"next":{"title":"要入职外包吗？","number":48}}},
    "staticQueryHashes": ["151096407","2861350382"]}