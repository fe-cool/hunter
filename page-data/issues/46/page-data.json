{
    "componentChunkName": "component---src-templates-issues-tsx",
    "path": "/issues/46",
    "result": {"data":{"issuesJson":{"id":"6c6e0225-fff9-5a03-804f-24d69abe032c","title":"虚拟DOM的意义是什么？","number":46,"bodyHTML":"\n<h3 dir=\"auto\">发生问题的场景</h3>\n\n<p dir=\"auto\">一些流行的前端框架会使用虚拟DOM技术，比如Vue、React。</p>\n<h3 dir=\"auto\">需要解决的问题</h3>\n\n<p dir=\"auto\">请从以下角度回答：</p>\n<ol dir=\"auto\">\n<li>为什么需要虚拟DOM？</li>\n<li>虚拟DOM有哪些优势？</li>\n<li>虚拟DOM有哪些劣势？</li>\n<li>如果不使用虚拟DOM，还有哪些替代方案？</li>\n</ol>\n<h3 dir=\"auto\">最佳答案评选标准</h3>\n\n<p dir=\"auto\">按以上角度尽可能详细回答</p>\n<h2 dir=\"auto\">最佳答案</h2>\n<p dir=\"auto\"><a href=\"https://github.com/BetaSu/fe-hunter/issues/46#issuecomment-1094266938\" data-hovercard-type=\"issue\" data-hovercard-url=\"/BetaSu/fe-hunter/issues/46/hovercard\">xwxgjs的回答</a></p>\n<h3 dir=\"auto\">答题同学须知</h3>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\">答题规范：请在<code class=\"notranslate\">一次评论</code>中完成作答，后续修改也请编辑该评论，而不是追加新的评论</p>\n</li>\n<li>\n<p dir=\"auto\">评选标准：最佳答案由<code class=\"notranslate\">围观同学</code>的 <g-emoji class=\"g-emoji\" alias=\"+1\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png\">👍</g-emoji> 和<a href=\"https://github.com/BetaSu\">卡颂</a>共同决定</p>\n</li>\n<li>\n<p dir=\"auto\">评选时间：一般是问题发布24小时后评选，如果问题发布当天回答数较少，问题悬赏金额可能增加，同时悬赏时间也会增加</p>\n</li>\n</ul>\n<h3 dir=\"auto\">围观同学须知</h3>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\">对于你满意的答案，请不要吝惜你的 <g-emoji class=\"g-emoji\" alias=\"+1\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png\">👍</g-emoji>，这是评选<strong>最佳答案</strong>的依据</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">非答题的评论</code>会被删除，问题相关讨论请在<a href=\"https://github.com/BetaSu/fe-hunter\">赏金猎人群</a>中进行</p>\n</li>\n</ul>","updatedAt":"2022-04-15T01:39:55Z","upvoteCount":null,"author":{"login":"BetaSu","avatarUrl":"https://avatars.githubusercontent.com/u/15828041?u=3b08cdf9f9b49dbead9ffb020a94d925904d2b74&v=4","url":"https://github.com/BetaSu"},"category":null,"labels":{"edges":[{"node":{"name":"JS","color":"ffee58"}},{"node":{"name":"React","color":"fbc02d"}},{"node":{"name":"Vue","color":"fdd835"}},{"node":{"name":"场景","color":"2196f3"}},{"node":{"name":"前端框架","color":"ff9100"}}]},"comments":{"edges":[{"node":{"id":"IC_kwDOHCfdf85A8zXE","bodyHTML":"<h3 dir=\"auto\"><strong>提高开发效率</strong></h3>\n<p dir=\"auto\">使用<code class=\"notranslate\">JavaScript 或</code> <code class=\"notranslate\">jQuery</code> ，我们在编写应用程序时，还需关注如何去更新<code class=\"notranslate\">DOM</code>。</p>\n<p dir=\"auto\">使用<code class=\"notranslate\">React</code>，因为有数据驱动视图，你只需要告诉<code class=\"notranslate\">React</code>你想让视图处于什么状态，<code class=\"notranslate\">React</code>则通过<code class=\"notranslate\">VitrualDom</code>确保<code class=\"notranslate\">DOM</code>与该状态相匹配。你不必自己去完成属性操作、事件处理、<code class=\"notranslate\">DOM</code>更新，<code class=\"notranslate\">React</code>会替你完成这一切。</p>\n<p dir=\"auto\">这让我们<strong>更关注我们的业务逻辑而非<code class=\"notranslate\">DOM</code>操作</strong>，这一点即可大大提升我们的开发效率。</p>\n<h3 dir=\"auto\"><strong>关于提升性能</strong></h3>\n<p dir=\"auto\"><strong>直接操作<code class=\"notranslate\">DOM</code>是非常耗费性能的</strong>，<strong>而JS计算要快的多</strong>，这一点毋庸置疑。但是<code class=\"notranslate\">React</code>使用<code class=\"notranslate\">VitrualDom</code>也是无法避免操作<code class=\"notranslate\">DOM</code>的。</p>\n<p dir=\"auto\">如果是首次渲染，<code class=\"notranslate\">VitrualDom</code>不具有任何优势，甚至它要进行更多的计算，消耗更多的内存。</p>\n<p dir=\"auto\"><code class=\"notranslate\">VitrualDom</code>的<strong>优势在于</strong><code class=\"notranslate\">React</code><strong>的</strong><code class=\"notranslate\">Diff</code><strong>算法复用</strong><code class=\"notranslate\">old结点</code><strong>找出差异和批处理策略</strong>，在这个过程中<code class=\"notranslate\">React</code>帮助我们\"提升了性能\"。</p>\n<p dir=\"auto\">所以，我更倾向于说，<code class=\"notranslate\">VitrualDom</code>帮助我们提高了开发效率，在重复渲染时它帮助我们计算如何更高效的更新，而不是它比<code class=\"notranslate\">DOM</code>操作更快。</p>\n<h3 dir=\"auto\"><strong>跨浏览器兼容</strong></h3>\n<p dir=\"auto\"><code class=\"notranslate\">React</code>基于<code class=\"notranslate\">VitrualDom</code>自己实现了一套自己的事件机制（合成事件），自己模拟了事件冒泡和捕获的过程，采用了事件代理，批量更新等方法，<strong>抹平了各个浏览器的事件兼容性问题</strong>。</p>\n<h3 dir=\"auto\"><strong>跨平台兼容</strong></h3>\n<p dir=\"auto\"><code class=\"notranslate\">VitrualDom</code>为<code class=\"notranslate\">React</code>带来了跨平台渲染的能力，<strong>虚拟DOM其实就是一层抽象层，可以让我们写的代码在多端表现一致</strong>。</p>\n<p dir=\"auto\">以<code class=\"notranslate\">React Native</code>为例子。<code class=\"notranslate\">React</code>根据<code class=\"notranslate\">VitrualDom</code>画出相应平台的<code class=\"notranslate\">ui</code>层，只不过不同平台画的姿势不同而已。</p>","author":{"login":"Travelguest","avatarUrl":"https://avatars.githubusercontent.com/u/42471249?u=da42abea217ddf6f316e2b887c7e2d270566f854&v=4","url":"https://github.com/Travelguest"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85A9UQI","bodyHTML":"<p dir=\"auto\">为什么需要虚拟DOM<br>\n虚拟DOM是一种声明式编程语言的设计模式，相反的jQuery应用是一种命令式编程语言。<br>\n现代应用中数据和UI的复杂交互需求越来越高，复杂的jQuery应用中我们常常难以从代码中看出数据和UI的关系，UI会因为前后的操作操作而产生变化，在维护代码时需要很抽象的思考UI的变化过程来推断代码是怎么执行和渲染的。<br>\n我觉得虚拟DOM就是解决这种痛点而被现代前端开发需要的，可以形成很好的数据和UI关系。</p>\n<p dir=\"auto\">虚拟DOM有哪些劣势<br>\n需要额外的性能消耗（大列表是个典型例子</p>\n<p dir=\"auto\">如果不使用虚拟DOM，还有哪些替代方案？<br>\nsvelte 静态编译框架？</p>","author":{"login":"blackcoffeecat","avatarUrl":"https://avatars.githubusercontent.com/u/43604283?v=4","url":"https://github.com/blackcoffeecat"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85A9f3D","bodyHTML":"<h3 dir=\"auto\">为什么需要虚拟DOM，有哪些优势？</h3>\n<p dir=\"auto\">我们使用jq、js的去获取dom节点、设置文本内容、绑定事件这种<strong>关注过程</strong>的，我们可以称之为<strong>命令式编程</strong><br>\n而像vue这种直接就是一个 div 里边有自己的属性，语法糖，文本内容等，只<strong>关注结果</strong>的，我们称之为<strong>声明式编程</strong></p>\n<p dir=\"auto\">使用虚拟DOM的原因很简单，减少疯狂的去获取dom元素，操作dom带来的心智负担，即使他的速度没有js直接操作dom来的更快，但是它<strong>方便</strong>啊，而且也能保证一个<strong>性能下限</strong>，就是你再差再差的情况我也能保证你最差也就到这个性能了</p>\n<p dir=\"auto\">另外虚拟DOM也<strong>方便跨平台操作</strong>，说白了他就是一个js对象，是js能够读得懂的</p>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Travelguest/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Travelguest\">@Travelguest</a> 大佬也是写的比较清楚了</p>\n<p dir=\"auto\">一句话总结：虚拟DOM降低开发的心智负担，保证性能下限，方便跨平台</p>\n<h3 dir=\"auto\">虚拟DOM有哪些劣势？</h3>\n<p dir=\"auto\">首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢</p>\n<h3 dir=\"auto\">如果不使用虚拟DOM，还有哪些替代方案？</h3>\n<p dir=\"auto\">上边提到了降低开发的心智负担，根本原因就是使用的是声明式编程，那么围绕这一点来说，只要是以这个思想出发的应该都算是一种解决方案。</p>\n<p dir=\"auto\">如果从性能上来说，其实虚拟DOM无非是尽可能的减少重绘、回流，那么使用<strong>createDocumentFragment</strong>来解决我认为也是一个比较好的思路出发点？</p>","author":{"login":"Btrya","avatarUrl":"https://avatars.githubusercontent.com/u/28686506?u=3dff612b3813986e212b18565ddb31a58a3843f8&v=4","url":"https://github.com/Btrya"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85A9gbj","bodyHTML":"<h1 dir=\"auto\">虚拟DOM目的就是抽象出真实DOM,方便框架在运行时找出更新的差异 然后更新视图</h1>\n<h1 dir=\"auto\">对于性能的提升：</h1>\n<p dir=\"auto\">框架底层也是要操作DOM的 然后去更新视图。相较于我们手动的操作DOM，有了虚拟DOM之后，框架本身会帮助我们找到最小的更新差异 少量的操作DOM。并不是虚拟DOM本身性能高。</p>\n<h1 dir=\"auto\">多平台</h1>\n<p dir=\"auto\">可以实现不同的渲染层，根据不同的平台特性实现响应的代码</p>","author":{"login":"Maidang1","avatarUrl":"https://avatars.githubusercontent.com/u/50993231?u=98b7ef2db007423e1ab78056693b130bd7966b1c&v=4","url":"https://github.com/Maidang1"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85A9oHV","bodyHTML":"<p dir=\"auto\">抽离真实DOM,对比更新渲染，减少回流</p>","author":{"login":"fxwing","avatarUrl":"https://avatars.githubusercontent.com/u/32068860?u=77df1f2776ae063e0d954db1e4600bf83afcb5ea&v=4","url":"https://github.com/fxwing"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85BE7Jo","bodyHTML":"<p dir=\"auto\">我来换个角度<br>\n先说结论, 虚拟dom是发展必然的结果</p>\n<p dir=\"auto\">先说前身 mvc 下的 dom 开发 先定义 model, 然后写一个 模版 view 或者 字符串拼接方法, 然后再 controller 里去跟进业务逻辑去 调用 createView(model) =&gt; dom , 再塞回 body, 这个逻辑下, 要往下优化就是 createView 里面 在做一堆 htmlcache 去缓存原本生成的逻辑.</p>\n<p dir=\"auto\">然后 mvc 自己做了一套 dom 缓存策略</p>\n<p dir=\"auto\">再来看 虚拟dom 这就是再最开始就把这个问题解决啦</p>","author":{"login":"NoBey","avatarUrl":"https://avatars.githubusercontent.com/u/10740524?u=6c74b36db878e34c1cf8d1b6e638285b11c1f3b6&v=4","url":"https://github.com/NoBey"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85BN6Y5","bodyHTML":"<h1 dir=\"auto\">1. 为什么需要虚拟DOM？</h1>\n<p dir=\"auto\">一个词：<strong>管理</strong>。</p>\n<p dir=\"auto\">从具体的角度： <code class=\"notranslate\">React</code> 借助 <code class=\"notranslate\">虚拟DOM</code> <strong>管理</strong>  <code class=\"notranslate\">浏览器渲染</code>。</p>\n<p dir=\"auto\">从开发的角度： <code class=\"notranslate\">开发者</code> 借助 <code class=\"notranslate\">抽象化数据</code> <strong>管理</strong>  <code class=\"notranslate\">UI</code>。</p>\n<p dir=\"auto\">举个例子：</p>\n<p dir=\"auto\">假如我们要实现打包工具：将前端项目打包成一个js文件。</p>\n<p dir=\"auto\">我们会想通过字符串，去试下你，但是这其实很难实现，因为字符串的抽象信息太少了。</p>\n<p dir=\"auto\">所以要借助 <strong>抽象语法树</strong>（<code class=\"notranslate\">AST</code>）。<code class=\"notranslate\">AST</code> 是对代码的抽象表达。</p>\n<p dir=\"auto\"><code class=\"notranslate\">webpack</code> 和 <code class=\"notranslate\">babel</code>借助<code class=\"notranslate\">AST</code>，<strong>管理</strong>代码。其中查找依赖、Tree Shaking、支持高版本JS特性等多个功能都依赖于<code class=\"notranslate\">AST</code>。</p>\n<p dir=\"auto\"><strong>当A要管理B的时候，将B的信息抽象化，才方便A去管理。</strong></p>\n<h1 dir=\"auto\">2. 虚拟DOM有哪些优势？</h1>\n<ul dir=\"auto\">\n<li>抽象化数据，方便了<code class=\"notranslate\">React</code> 实现多种需求。</li>\n<li>支持多平台\n<ul dir=\"auto\">\n<li>浏览器、移动端、服务器、自定义的，例如Trao(小程序)，桌面端等。</li>\n</ul>\n</li>\n<li>提高开发效率\n<ul dir=\"auto\">\n<li>通过<code class=\"notranslate\">VDOM</code>可以将DOM操作，抽象到专门的模块去处理，减少开发者对DOM的操作。</li>\n</ul>\n</li>\n<li>性能优化\n<ul dir=\"auto\">\n<li>通过<code class=\"notranslate\">VDOM</code> ，来实现组件树的对比，复用DOM节点。\n<ul dir=\"auto\">\n<li>在DIFF上我个人认为，DIFF更多是React帮助自己提升性能。因为React是脏检查，全量树对比。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>提高可维护性</li>\n<li>提高可测试\n<ul dir=\"auto\">\n<li><code class=\"notranslate\">VDOM</code> 使得前端组件方便进行测试。</li>\n</ul>\n</li>\n</ul>\n<h1 dir=\"auto\">3. 虚拟DOM有哪些劣势？</h1>\n<ul dir=\"auto\">\n<li>高运行时\n<ul dir=\"auto\">\n<li>在运行时也要生成和处理<code class=\"notranslate\">VDOM</code> ，这部分的运行时开销不小。</li>\n</ul>\n</li>\n<li>高内存开销\n<ul dir=\"auto\">\n<li>一棵组件树 <code class=\"notranslate\">VDOM</code> 要生成很多对象数据，这会占用很高的内存开销。</li>\n</ul>\n</li>\n</ul>\n<h1 dir=\"auto\">4. 如果不使用虚拟DOM，还有哪些替代方案？</h1>\n<p dir=\"auto\">在运行时没有虚拟DOM的方案：</p>\n<ul dir=\"auto\">\n<li>响应式\n<ul dir=\"auto\">\n<li>通过 <code class=\"notranslate\">date</code>直接和<code class=\"notranslate\">view</code>挂钩，需要借助<code class=\"notranslate\">Proxy</code>等。</li>\n</ul>\n</li>\n<li>强编译\n<ul dir=\"auto\">\n<li>直接编译出<code class=\"notranslate\">dom</code> + <code class=\"notranslate\">dom操作</code> + <code class=\"notranslate\">data</code></li>\n<li>相当于从前写JS、JQ，但是在编译时进行分析，直接编译出对应DOM和操作和数据的源码。</li>\n</ul>\n</li>\n</ul>\n<h1 dir=\"auto\">我对问题的疑问</h1>\n<ul dir=\"auto\">\n<li>问题的虚拟DOM是什么？\n<ul dir=\"auto\">\n<li>我认为React中JSX（ReactElement）、Fiber都算是虚拟DOM。\n<ul dir=\"auto\">\n<li>例如DIFF时，我们说是虚拟DOM在DIFF，React源码就是JSX（ReactElement）和Fiber在进行DIFF。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>第4问不用虚拟DOM的说法很奇怪，是指在运行时没有虚拟DOM吗？\n<ul dir=\"auto\">\n<li>现在所有的框架都会写<code class=\"notranslate\">JSX</code>语法，<code class=\"notranslate\">JSX</code> 实际在多数框架中都会被处理为 <code class=\"notranslate\">VDOM</code> 。</li>\n<li>只是最终结果不同，有多种情况。\n<ul dir=\"auto\">\n<li>VDOM只在编译时有。</li>\n<li>VDOM只在运行时有。</li>\n<li>VDOM在运行时，编译时都有。</li>\n</ul>\n</li>\n<li>是指抽象化数据，完全没有。处理字符串一样进行处理吗？</li>\n</ul>\n</li>\n</ul>\n<p dir=\"auto\">提个思考题：HTML文件算不算“虚拟DOM”？</p>","author":{"login":"liu-zhi-fei","avatarUrl":"https://avatars.githubusercontent.com/u/23424487?u=35ea4cb8cf3e6f7ae61733eb5b7e8a45f5f1571d&v=4","url":"https://github.com/liu-zhi-fei"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85BN9sM","bodyHTML":"<blockquote>\n<p dir=\"auto\">提个思考题：HTML文件算不算“虚拟DOM”？</p>\n</blockquote>\n<p dir=\"auto\">DOM = 文档对象模型，HTML = 超文本标记语言。<br>\n标记语言描述了文档对象，可以理解为文档对象模型在某种环境下的 DSL。</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://user-images.githubusercontent.com/77133362/162602574-97ba9aa7-a78f-4e3c-8901-e9ecf9772d40.png\"><img src=\"https://user-images.githubusercontent.com/77133362/162602574-97ba9aa7-a78f-4e3c-8901-e9ecf9772d40.png\" alt=\"图片\" style=\"max-width: 100%;\"></a></p>\n<p dir=\"auto\">AST 是对 JavaScript 代码的抽象，那么 DOM 是对 HTML 的抽象？有点奇怪。</p>\n<p dir=\"auto\">不过根据上面的类比，HTML 肯定是不算虚拟 DOM 的。 <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/liu-zhi-fei/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/liu-zhi-fei\">@liu-zhi-fei</a></p>","author":{"login":"wxyunhe","avatarUrl":"https://avatars.githubusercontent.com/u/77133362?u=bffe37877d774b1280b3de477f8dd80b905c7578&v=4","url":"https://github.com/wxyunhe"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85BOTA6","bodyHTML":"<p dir=\"auto\">谈论虚拟 DOM 之前，我们先明确一个概念：DOM</p>\n<p dir=\"auto\">根据 MDN 的说法：</p>\n<blockquote>\n<p dir=\"auto\">文档对象模型 (DOM) 是 HTML 和 XML 文档的编程接口。</p>\n<p dir=\"auto\">它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。</p>\n<p dir=\"auto\">简言之，它会将 web 页面和脚本或程序语言连接起来。</p>\n</blockquote>\n<p dir=\"auto\">这里有两个重点：</p>\n<ul dir=\"auto\">\n<li>HTML 和 DOM 之间是有映射关系的，DOM 是对 HTML 的结构化描述</li>\n<li>通过 DOM 可以对文档进行访问和操作</li>\n</ul>\n<p dir=\"auto\">我们可以建立这样一个对应关系：</p>\n<p dir=\"auto\"><code class=\"notranslate\">HTML -&gt; DOM -&gt; JS</code></p>\n<p dir=\"auto\">换句话说，只要有了 DOM，实际上就可以支撑 Vue、React 等框架对文档的操作了。毕竟现在提到的虚拟 DOM 和 DOM 都是结构化的信息，同样可以进行 diff、patch 操作。</p>\n<p dir=\"auto\">那为什么还需要虚拟 DOM 呢？虚拟 DOM 为我们带来了什么？</p>\n<p dir=\"auto\">首先，添加虚拟 DOM 之后，对应关系变成了这样：</p>\n<p dir=\"auto\"><code class=\"notranslate\">HTML -&gt; DOM -&gt; 虚拟 DOM -&gt; JS</code></p>\n<p dir=\"auto\">从性能上考虑，通过 DOM 提供的接口获取文档的位置、样式，并对其进行更改。如果文档已经被渲染在浏览器中，可能会触发浏览器的重绘和回流机制，如果多次触发，对性能的影响极大。如果说直接操作 DOM，很容易出现这种问题。</p>\n<p dir=\"auto\">那有人会提出：如果没有在屏幕中渲染出来，那么就可以绕过这部分性能开销。我们可以创建一个 DOM 片段出来，这个 DOM 片段不插入到文档中，对这个 DOM 片段进行操作，当一次操作完成后插入到文档中。</p>\n<blockquote>\n<p dir=\"auto\">其实这个方案就是 Canvas 开发时的“离屏层”概念。</p>\n</blockquote>\n<p dir=\"auto\">这其实有了虚拟 DOM 的影子。</p>\n<p dir=\"auto\">但是这个方案也有问题：框架进行操作时，其实并不需要 DOM 上的那么多方法，这些方法会占用更多的内存空间。</p>\n<p dir=\"auto\">转念一想，既然我已经将 DOM 隔离一层出来，还不如创建一套自己需要的模型，仅保留需要的操作方法。这就是现在用到的虚拟 DOM 了。</p>\n<p dir=\"auto\">这样增加的虚拟 DOM 层，仅保留自己需要的内容，降低了开发者的理解成本。<br>\n同时也抹平了不同浏览器引擎对 DOM 操作实现的差异，开发者不需要再关注各个引擎的具体实现了。<br>\n后来发现，如果对虚拟 DOM 进行操作，HTML 部分完全可以替换成其他的文档环境，通用性会更强。</p>\n<p dir=\"auto\">所以我们可以回答下面的问题了：</p>\n<h2 dir=\"auto\">为什么需要虚拟 DOM？</h2>\n<ol dir=\"auto\">\n<li>为了降低对 DOM 操作引发的渲染开销</li>\n<li>为了降低开发者的理解成本</li>\n</ol>\n<h2 dir=\"auto\">虚拟 DOM 有哪些优势？</h2>\n<ol dir=\"auto\">\n<li>性能：隔离了对文档的操作，降低渲染成本</li>\n<li>跨平台：可以通过一套模型适配多种渲染平台</li>\n<li>可维护性：虚拟 DOM 抹平了不同平台 API 的区别，仅保留所需的操作方法，降低理解成本，提升可维护性</li>\n</ol>\n<h2 dir=\"auto\">虚拟 DOM 有哪些劣势？</h2>\n<ol dir=\"auto\">\n<li>不适用对真实 DOM 需要操作的场景。使用虚拟 DOM 的框架不建议用户操作 DOM，所有的 DOM 操作都由框架进行。如果你真的需要获取真实 DOM 操作，比如使用 canvas 绘制动画，读取 DOM 上的 dataset 属性等操作，虚拟 DOM 是不支持的。</li>\n<li>如果说有外部引入的 DOM 操作，比如说使用插入一个新的 div，虚拟 DOM 是无法检测到的，需要在操作后调用框架 API 手动通知。</li>\n<li>运行时和内存开销：相对直接操作 DOM，虚拟 DOM 实际上相当于引入了一个镜像，只是这个镜像占用的内存稍微小一点。同时在一次加载大量 DOM 的时候，虚拟 DOM 需要处理的内容较多，也会降低峰值性能。</li>\n</ol>\n<h2 dir=\"auto\">如果不使用虚拟 DOM，还有哪些替代方案？</h2>\n<ul dir=\"auto\">\n<li>如果说运行时不使用，可以用 svelte 等预编译的框架。</li>\n<li>如果说开发时也不使用，直接上模板引擎（比如 handlebar），或者直接操作 DOM 的框架和原生操作</li>\n</ul>","author":{"login":"wxyunhe","avatarUrl":"https://avatars.githubusercontent.com/u/77133362?u=bffe37877d774b1280b3de477f8dd80b905c7578&v=4","url":"https://github.com/wxyunhe"},"replies":null}}]}}},"pageContext":{"number":46,"previous":{"title":"Webpack中几种hash的区别是？","number":43},"next":{"title":"get与post请求的区别是？","number":47}}},
    "staticQueryHashes": ["151096407","2861350382"]}