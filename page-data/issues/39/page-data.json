{
    "componentChunkName": "component---src-templates-issues-tsx",
    "path": "/issues/39",
    "result": {"data":{"issuesJson":{"id":"28e3e24f-5cd9-5ee6-ba7a-6bf1ff507793","title":"Vue应用卡顿该如何排查？","number":39,"bodyHTML":"\n<h3 dir=\"auto\">发生问题的场景</h3>\n\n<p dir=\"auto\">用户反馈你们的应用操作起来卡顿，应用是<code class=\"notranslate\">React</code>开发的。</p>\n<h3 dir=\"auto\">需要解决的问题</h3>\n\n<p dir=\"auto\">你该如何排查是哪些组件造成性能瓶颈？请写出你的排查步骤</p>\n<p dir=\"auto\"><g-emoji class=\"g-emoji\" alias=\"warning\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/26a0.png\">⚠️</g-emoji> 本题的重点是排查<code class=\"notranslate\">组件</code>性能瓶颈，请将重点放在<code class=\"notranslate\">Vue</code>上，而不是通用的性能优化策略</p>\n<h3 dir=\"auto\">最佳答案评选标准</h3>\n\n<ol dir=\"auto\">\n<li>回答条理清晰</li>\n<li>从<code class=\"notranslate\">Vue</code>角度排查问题</li>\n</ol>\n<h2 dir=\"auto\">最佳答案</h2>\n<p dir=\"auto\"><a href=\"https://github.com/BetaSu/fe-hunter/issues/39#issuecomment-1084022004\" data-hovercard-type=\"issue\" data-hovercard-url=\"/BetaSu/fe-hunter/issues/39/hovercard\">fightZy的回答</a></p>\n<h3 dir=\"auto\">答题同学须知</h3>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\">答题规范：请在<code class=\"notranslate\">一次评论</code>中完成作答，后续修改也请编辑该评论，而不是追加新的评论</p>\n</li>\n<li>\n<p dir=\"auto\">评选标准：最佳答案由<code class=\"notranslate\">围观同学</code>的 <g-emoji class=\"g-emoji\" alias=\"+1\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png\">👍</g-emoji> 和<a href=\"https://github.com/BetaSu\">卡颂</a>共同决定</p>\n</li>\n<li>\n<p dir=\"auto\">评选时间：一般是问题发布24小时后评选，如果问题发布当天回答数较少，问题悬赏金额可能增加，同时悬赏时间也会增加</p>\n</li>\n</ul>\n<h3 dir=\"auto\">围观同学须知</h3>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\">对于你满意的答案，请不要吝惜你的 <g-emoji class=\"g-emoji\" alias=\"+1\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png\">👍</g-emoji>，这是评选<strong>最佳答案</strong>的依据</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">非答题的评论</code>会被删除，问题相关讨论请在<a href=\"https://github.com/BetaSu/fe-hunter\">赏金猎人群</a>中进行</p>\n</li>\n</ul>","updatedAt":"2022-04-08T01:46:59Z","upvoteCount":null,"author":{"login":"BetaSu","avatarUrl":"https://avatars.githubusercontent.com/u/15828041?u=3b08cdf9f9b49dbead9ffb020a94d925904d2b74&v=4","url":"https://github.com/BetaSu"},"category":null,"labels":{"edges":[{"node":{"name":"JS","color":"ffee58"}},{"node":{"name":"Vue","color":"fdd835"}},{"node":{"name":"性能优化","color":"CCEC29"}},{"node":{"name":"场景","color":"2196f3"}}]},"comments":{"edges":[{"node":{"id":"IC_kwDOHCfdf85AnNz0","bodyHTML":"<h3 dir=\"auto\">1.检查组件的watcher</h3>\n<p dir=\"auto\">​\t是不是watch了过多的东西？</p>\n<p dir=\"auto\">​\t是不是deep watch了大对象？</p>\n<p dir=\"auto\">​\t 是不是有些watcher之间形成了一些循环嵌套，导致了一些逻辑重复执行？</p>\n<p dir=\"auto\">​\t 如何检查：</p>\n<p dir=\"auto\">​\t\t\t依赖devtools的performance分析一下，看看卡顿的时候是不是执行了很多<strong>notify</strong>、<strong>update</strong>；</p>\n<h3 dir=\"auto\">2.组件销毁后是否能被GC</h3>\n<p dir=\"auto\">​\t即检查是不是有组件<strong>内存泄漏</strong>的问题，vue组件对象如果销毁后有内存泄漏问题无法被回收，那内存就会逐渐变大，以至于造成卡顿；</p>\n<p dir=\"auto\">​\t以我个人经验，一般造成vue组件内存泄漏的原因普遍是有：</p>\n<p dir=\"auto\">​\t\t1.在组件中挂载的监听回调等没有在销毁时取消监听；</p>\n<p dir=\"auto\">​\t\t2.当前组件被外部组件引用；</p>\n<p dir=\"auto\">​\t\t3.组件内的某些操作污染到全局作用域；</p>\n<p dir=\"auto\">​\t如何检查：</p>\n<p dir=\"auto\">​\t\t依赖devtools的Memory，在使用有问题的组件前进行一次内存快照（<em>注意：如果组件是懒加载的话需要先让其加载一次，才能再测试时忽略掉组件本身固有的大小</em>），然后多次操作有问题的组件，退出后，点击collect rubbish，手动执行GC，再进行一次内存快照；</p>\n<p dir=\"auto\">​\t\t这时候我们就可以对比两次内存快照的区别，找出多出来且没有被回收的内容<br>\n<a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://user-images.githubusercontent.com/52490455/160970434-1bf8ac48-ced1-48d6-a986-5840b296cabd.png\"><img src=\"https://user-images.githubusercontent.com/52490455/160970434-1bf8ac48-ced1-48d6-a986-5840b296cabd.png\" alt=\"image\" style=\"max-width: 100%;\"></a></p>","author":{"login":"fightZy","avatarUrl":"https://avatars.githubusercontent.com/u/52490455?u=4a008fd4e5a82484f5eec0f82487368910fc9f65&v=4","url":"https://github.com/fightZy"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AnhCo","bodyHTML":"<p dir=\"auto\">如果 表现为：<br>\n进行某一次操作且数据更新后，页面需要较长的时间才渲染为最新状态（每次操作都会明显滞后，但不影响后续的其他操作<br>\n需要排查：模版渲染中高频率使用的filter或者函数是否执行耗时较长</p>\n<p dir=\"auto\">如果 表现为：<br>\n进行某一次操作且数据更新后，页面已渲染为最新状态，但在后续一段时间内，用户的操作响应都有明显的滞后<br>\n需要排查：是否循环触发了同一个watcher/nextTick</p>","author":{"login":"blackcoffeecat","avatarUrl":"https://avatars.githubusercontent.com/u/43604283?v=4","url":"https://github.com/blackcoffeecat"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85A43TM","bodyHTML":"<p dir=\"auto\">上面说的挺好的, 我来个通用点的</p>\n<p dir=\"auto\">半定位法 (名称来源: OD免杀半定位法)<br>\n一次注释掉一半(或者关闭掉一半的代码引用), 然后只看另一半是否会出现问题<br>\n及时你不知道原因, 也能缩小问题的范围</p>","author":{"login":"NoBey","avatarUrl":"https://avatars.githubusercontent.com/u/10740524?u=6c74b36db878e34c1cf8d1b6e638285b11c1f3b6&v=4","url":"https://github.com/NoBey"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85A9pOh","bodyHTML":"<p dir=\"auto\">渲染前卡：模版中的filter/computed执行时间长<br>\n渲染后卡：watch中深递归</p>","author":{"login":"fxwing","avatarUrl":"https://avatars.githubusercontent.com/u/32068860?u=77df1f2776ae063e0d954db1e4600bf83afcb5ea&v=4","url":"https://github.com/fxwing"},"replies":null}}]}}},"pageContext":{"number":39,"previous":{"title":"实现核辐射警告标志","number":38},"next":{"title":"Webpack中几种hash的区别是？","number":43}}},
    "staticQueryHashes": ["151096407","2861350382"]}