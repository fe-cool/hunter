{
    "componentChunkName": "component---src-templates-issues-tsx",
    "path": "/issues/9",
    "result": {"data":{"issuesJson":{"id":"d3843e2c-8616-5d70-b8a5-abdf65bfcd29","title":"如何选择前端打包工具？","number":9,"bodyHTML":"<h2 dir=\"auto\">问题描述</h2>\n\n\n<p dir=\"auto\">当前市面上有很多前端打包工具，比如：</p>\n<ul dir=\"auto\">\n<li>webpack</li>\n<li>rollup</li>\n<li>vite</li>\n<li>parcel</li>\n<li>browserify</li>\n</ul>\n<p dir=\"auto\">他们各有侧重，又有功能交集。当你在搭建一个新项目时，该如何选择打包工具呢？可以从以下方面回答：</p>\n<ul dir=\"auto\">\n<li>打包工具适合的业务场景？</li>\n<li>打包工具社区生态是否丰富？</li>\n<li>打包工具的可扩展性？</li>\n<li>打包工具的上手难度</li>\n<li>......</li>\n</ul>\n<h2 dir=\"auto\">最佳答案</h2>\n<p dir=\"auto\"><a href=\"https://github.com/BetaSu/fe-hunter/issues/9#issuecomment-1077019965\" data-hovercard-type=\"issue\" data-hovercard-url=\"/BetaSu/fe-hunter/issues/9/hovercard\">XeryYue的回答</a></p>\n<h3 dir=\"auto\">答题同学须知</h3>\n<p dir=\"auto\">最佳答案由<code class=\"notranslate\">围观同学</code>的<code class=\"notranslate\">👍</code>和<a href=\"https://github.com/BetaSu\">卡颂</a>共同决定。<strong>非答题相关评论</strong>会被删除，问题相关内容讨论请在<a href=\"https://github.com/BetaSu/fe-hunter\">赏金猎人群</a>里讨论</p>\n<h3 dir=\"auto\">围观同学须知</h3>\n<p dir=\"auto\">对于你满意的答案，请不要吝惜你的<code class=\"notranslate\">👍</code>，这是评选<strong>最佳答案</strong>的标准</p>","updatedAt":"2022-03-29T02:09:16Z","upvoteCount":null,"author":{"login":"BetaSu","avatarUrl":"https://avatars.githubusercontent.com/u/15828041?u=3b08cdf9f9b49dbead9ffb020a94d925904d2b74&v=4","url":"https://github.com/BetaSu"},"category":null,"labels":{"edges":[{"node":{"name":"工程化","color":"ffca28"}},{"node":{"name":"webpack","color":"ff8f00"}},{"node":{"name":"Vite","color":"ff6f00"}},{"node":{"name":"场景","color":"2196f3"}}]},"comments":{"edges":[{"node":{"id":"IC_kwDOHCfdf85AMgU9","bodyHTML":"<p dir=\"auto\">关于打包这个问题是一个很有考究的学问,不论是<code class=\"notranslate\">bundle</code>还是<code class=\"notranslate\">transform</code>,存在即合理。这里我会以我个人的经历浅谈如何选择打包工具链。</p>\n<h3 dir=\"auto\">明确工程场景</h3>\n<p dir=\"auto\">在后续选择打包工具之前,我们应该先思考的是我们的工程服务的群体是什么样的,是类库还是应用工程。先想明白服务群体才能更好的选择工具。这里先给出我自己的结论如果不是应用工程大可不比<code class=\"notranslate\">bundle</code>而是选择<code class=\"notranslate\">transform</code>。关于这点我会在后续的部分进行详细展开。</p>\n<h3 dir=\"auto\">组件类库的选择</h3>\n<p dir=\"auto\">这里我们以类库方向的工程进行切入点,在搭建一个类库工程 <code class=\"notranslate\">gulp</code>+<code class=\"notranslate\">babel</code>是一个很好的解决方案。一个负责对<code class=\"notranslate\">disk</code>进行<code class=\"notranslate\">IO</code>,一个负责<code class=\"notranslate\">transform</code>然后把结果给<code class=\"notranslate\">gulp</code>进行输出。我们可以观看很多大型lib都是采取这么一个模式。在现代的工程我们不需要对一个类库进行打包因为打包以后在使用你会面临着二次打包,这一点我们从无数组件库便可窥得一二。因为在使用的时候我们往往是引入对应的组件部分而不是整个<code class=\"notranslate\">entry</code>。所以<code class=\"notranslate\">transform</code>的使用场景基本集中于此。那么不是组件库的库我们该怎么做？这里就以我在维护的<code class=\"notranslate\">h265webjs</code>举例<a href=\"https://github.com/numberwolf/h265web.js\">项目地址</a>, 因为这个项目足够小它不需要<code class=\"notranslate\">webpack</code>这样的重型工具，<code class=\"notranslate\">browserify</code>提供的模块功能足够我们使用。因此我们就会使用他。</p>\n<h3 dir=\"auto\">其他类库的选择</h3>\n<p dir=\"auto\">相较于<code class=\"notranslate\">babel</code>，<code class=\"notranslate\">swc</code>,<code class=\"notranslate\">tsc</code>+ 磁盘IO的操作,有些时候我们不约而同的看到了<code class=\"notranslate\">rollup</code>+<code class=\"notranslate\">api-extractor</code>的组合方案，这里以我个人角度来看,这些往往适合于纯<code class=\"notranslate\">js</code>的库。比如<code class=\"notranslate\">vue</code>。我们先看<code class=\"notranslate\">rollup</code>的描述将无数小的模块聚合成一个大的模块。那么在这些大型<code class=\"notranslate\">js</code><br>\n库往往需要把这些模块整合方便输出不同环境下的包,这点是纯<code class=\"notranslate\">transform</code>所做不到的,具体的最佳实践我们可以看看vue,出色的利用了<code class=\"notranslate\">rollup</code>完成不同模式的打包。</p>\n<h3 dir=\"auto\">应用工程</h3>\n<p dir=\"auto\">说完了类库的选择，就剩下了工程相关的了。关于<code class=\"notranslate\">vite</code>,<code class=\"notranslate\">webpack</code>,<code class=\"notranslate\">parcel</code>都是作为一些上层解决方案这里给出我的经验,现阶段除了<code class=\"notranslate\">webpack</code>都不靠谱。<code class=\"notranslate\">vite</code>给我最大的感受就是缝合了<code class=\"notranslate\">rollup</code>但是顺带把<code class=\"notranslate\">rollup</code>的bug也一起缝进来了。这种强依赖于上游的包。在面对复杂的前端应用工程往往无法面面俱到。因此我们看到了在面对低版本兼容的需求下<code class=\"notranslate\">vite</code>是无法升任的。这一点也和<code class=\"notranslate\">rollup</code>有关系。因为<code class=\"notranslate\">rollup</code>在设计之初就不是为<code class=\"notranslate\">web</code>应用开发服务的。反观<code class=\"notranslate\">webpack</code>这种虽然大但是在面对复杂的场景他是游刃有余的。无论是从社区生态还是近乎完美的打包支持webpack占据着绝对的地位。<code class=\"notranslate\">webpack</code>的抽象程度之所以复杂是因为承担的场景不是其他的打包工具能比拟的这一点也是经常被人诟病,但是推倒重来我们真的可以做得更好吗？再谈谈新晋的宠儿<code class=\"notranslate\">parcel</code>。我有幸使用过一次给我的感觉也是和<code class=\"notranslate\">vite</code>差不多也不再展开。<br>\n至于已经死去的<code class=\"notranslate\">snowPack</code> 大概是我对<code class=\"notranslate\">bundleless</code>的最后一丝幻想了吧。</p>","author":{"login":"nonzzz","avatarUrl":"https://avatars.githubusercontent.com/u/52351095?u=6f6f36a4ced0620abe20704520835a1fdf67fef2&v=4","url":"https://github.com/nonzzz"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AMnAX","bodyHTML":"<p dir=\"auto\">非跨端项目，我推荐vite。</p>\n<p dir=\"auto\">它由no-bundler开发服务器和rollup bundler两部分组成。</p>\n<p dir=\"auto\">vite可以给开发者带来极速的开发体验，借助rollup成熟的插件生态可以输出符合生产环境的产物。</p>\n<p dir=\"auto\">跨端项目的话，目前是webpack比较成熟，速度是慢了点，聊胜于无，期待下一款跨端vite生产工具的诞生。</p>","author":{"login":"coconilu","avatarUrl":"https://avatars.githubusercontent.com/u/8131019?u=7512234b500b63ff69170a287f2fa64d72a12c55&v=4","url":"https://github.com/coconilu"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AMpAP","bodyHTML":"<p dir=\"auto\">我只用过 webpack，组里项目直接 vue-cli<g-emoji class=\"g-emoji\" alias=\"sweat\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f613.png\">😓</g-emoji>。</p>","author":{"login":"songjingwei","avatarUrl":"https://avatars.githubusercontent.com/u/42341344?u=300ac46e2bdb4759ed417554099d3d2f6abe58ac&v=4","url":"https://github.com/songjingwei"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85ANpbW","bodyHTML":"<p dir=\"auto\">简单项目不想累，快速的话，用parcel，开发的库选择 rollup，因为不包含多余的代码，如果目前一般传统项目，还是用webpack，尝尝鲜用 es-build</p>","author":{"login":"ygh1","avatarUrl":"https://avatars.githubusercontent.com/u/22540197?u=a0f61d4974c6c031db8bdaac20a477523aa3b8aa&v=4","url":"https://github.com/ygh1"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85ANpd3","bodyHTML":"<p dir=\"auto\">上班不能摸鱼，时间紧，快点说<br>\n写类库 打包用rollup<br>\n写应用打包用webpack<br>\n不考虑兼容性用vite<br>\n其实ts的东西，直接tsc也挺好<br>\nsnowPack 、swc、parcel等等等这些，学太多容易把自己累死。</p>\n<p dir=\"auto\">补一下。选类库要看你项目大小、工程体系、面向的对象、使用的语言、甚至还有你团队的技术栈，你的剩余时间这些东西综合考虑的。不能一概而论。</p>","author":{"login":"sdta25196","avatarUrl":"https://avatars.githubusercontent.com/u/31121105?u=932a72684d1ee884cac57d960798957e70a8ce30&v=4","url":"https://github.com/sdta25196"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85Ac7Lw","bodyHTML":"<p dir=\"auto\">对于 TypeScript 编写的类库来说，使用<code class=\"notranslate\">rollup</code> + <code class=\"notranslate\">api-extractor</code> 肯定是最佳实践，<code class=\"notranslate\">rollup</code>负责构建生成 JS 文件，<code class=\"notranslate\">api-extractor</code>负责汇总<code class=\"notranslate\">.d.ts</code>文件，<code class=\"notranslate\">vite</code>就是这么干的。</p>","author":{"login":"wood3n","avatarUrl":"https://avatars.githubusercontent.com/u/31716713?u=b8b5fc87885be46078a2d2f96676f1d938396f87&v=4","url":"https://github.com/wood3n"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85Ac7du","bodyHTML":"<blockquote>\n<p dir=\"auto\">对于 TypeScript 编写的类库来说，使用<code class=\"notranslate\">rollup</code> + <code class=\"notranslate\">api-extractor</code> 肯定是最佳实践，<code class=\"notranslate\">rollup</code>负责构建生成 JS 文件，<code class=\"notranslate\">api-extractor</code>负责汇总<code class=\"notranslate\">.d.ts</code>文件，<code class=\"notranslate\">vite</code>就是这么干的。</p>\n</blockquote>\n<p dir=\"auto\"><code class=\"notranslate\">api-extractor</code>是要看具体场景的。不是每个都适用,例如组件库这样的类型他是不适合的</p>","author":{"login":"nonzzz","avatarUrl":"https://avatars.githubusercontent.com/u/52351095?u=6f6f36a4ced0620abe20704520835a1fdf67fef2&v=4","url":"https://github.com/nonzzz"},"replies":null}}]}}},"pageContext":{"number":9,"previous":{"title":"遇到线上bug该如何处理？","number":8},"next":{"title":"实现一个LazyMan","number":13}}},
    "staticQueryHashes": ["151096407","2861350382"]}