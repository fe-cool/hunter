{
    "componentChunkName": "component---src-templates-issues-tsx",
    "path": "/issues/3",
    "result": {"data":{"issuesJson":{"id":"c89d2ce7-767b-57e6-9760-3ccad8ea9e5b","title":"React应用卡顿该如何排查？","number":3,"bodyHTML":"<h2 dir=\"auto\">问题描述</h2>\n\n\n<p dir=\"auto\">用户反馈你们的应用操作起来卡顿，应用是<strong>React</strong>开发的，你该如何排查是哪些组件造成性能瓶颈？请写出你的排查步骤</p>\n<p dir=\"auto\"><g-emoji class=\"g-emoji\" alias=\"warning\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/26a0.png\">⚠️</g-emoji> 本题的重点是排查组件性能瓶颈，请将重点放在<strong>React</strong>上，而不是通用的性能优化策略</p>\n<h2 dir=\"auto\">最佳答案</h2>\n<p dir=\"auto\"><a href=\"https://github.com/BetaSu/fe-hunter/issues/3#issuecomment-1074714192\" data-hovercard-type=\"issue\" data-hovercard-url=\"/BetaSu/fe-hunter/issues/3/hovercard\">jerry-lllman的回答</a></p>\n<h2 dir=\"auto\">答题同学须知</h2>\n<p dir=\"auto\">最佳答案由<code class=\"notranslate\">围观同学</code>的<code class=\"notranslate\">👍</code>和<a href=\"https://github.com/BetaSu\">卡颂</a>共同决定。<strong>非答题相关评论</strong>会被删除，问题相关内容讨论请在<a href=\"https://github.com/BetaSu/fe-hunter\">赏金猎人群</a>里讨论</p>\n<h2 dir=\"auto\">围观同学须知</h2>\n<p dir=\"auto\">对于你满意的答案，请不要吝惜你的<code class=\"notranslate\">👍</code>，这是评选<strong>最佳答案</strong>的标准</p>","updatedAt":"2022-03-24T12:40:11Z","upvoteCount":null,"author":{"login":"BetaSu","avatarUrl":"https://avatars.githubusercontent.com/u/15828041?u=3b08cdf9f9b49dbead9ffb020a94d925904d2b74&v=4","url":"https://github.com/BetaSu"},"category":null,"labels":{"edges":[{"node":{"name":"JS","color":"ffee58"}},{"node":{"name":"React","color":"fbc02d"}},{"node":{"name":"性能优化","color":"CCEC29"}},{"node":{"name":"场景","color":"2196f3"}}]},"comments":{"edges":[{"node":{"id":"IC_kwDOHCfdf85ADo_D","bodyHTML":"<p dir=\"auto\">react-devtools</p>","author":{"login":"adminfyy","avatarUrl":"https://avatars.githubusercontent.com/u/15939820?v=4","url":"https://github.com/adminfyy"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85ADpLJ","bodyHTML":"<ol dir=\"auto\">\n<li>先检查是否是网络请求太多，导致数据返回较慢，可以适当做一些缓存</li>\n<li>再检查是否是某块资源的bundle太大，可以考虑拆分一下(要是有打包报告类似于 vue-cli的report就更好了)</li>\n<li>然后排查一下js代码，是不是某处有过多循环导致占用主线程时间过长</li>\n<li>接着检查是否是浏览器某帧渲染的东西太多，导致的卡顿</li>\n<li>在页面渲染过程中，可能有很多重复的重排重绘</li>\n<li>看看有没有内存泄漏啥的</li>\n<li>努力优化组件，是否因为数据变动太多导致的延缓</li>\n</ol>","author":{"login":"wanlum","avatarUrl":"https://avatars.githubusercontent.com/u/11306760?u=9b7ddfcfc1773b3100f62d54635008358a5ffda9&v=4","url":"https://github.com/wanlum"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85ADtZQ","bodyHTML":"<ol dir=\"auto\">\n<li>使用 Performance 录制应用快照，查看调用情况</li>\n<li>查看network中网络请求情况，是否有资源因过大请求阻塞，导致后续资源无法加载，这种情况一般选择分包或固定资源选择cdn分担（多域名。浏览器设置的http2.0以下同域名仅允许同时最多6个tcp的限制）</li>\n<li>可以通过 React Developer Tools 的 Profiler 的 Flamegraph（火焰图）或 Ranked（渲染时长排行榜） 查看各组件的渲染时长，根据对应的组件可以进行排查渲染问题，以下作答：<br>\na). 通过检查代码中是否有重复触发的 useEffect<br>\nb). 检查是否有多次不同渲染周期中触发的setState导致的渲染（比如在一个事件中导致的state更新，导致依赖于该state的useEffect触发，而该effect中又有其他的setState，导致多个有依赖项的useEffect不同批次连环触发）<br>\nc). 检查是否在某个超大组件中需要渲染的元素过多，可使用子组件可考虑使用 pureComponent，或 React.mome ，或使用useMome来根据依赖项更新子组件，或在父组件中将子组件需要的props通过使用useMome或useCallback缓存，  或在子组件中使用 shouldComponentUpdate 中校验是否需要更新来减少更新<br>\nd). 检查是否存在拖拽业务，这类业务一般会导致大量的diff存在，可以的话可以考虑不使用React的方式去实现，使用第三方非React的JS库去实现。<br>\ne). 同上情况，存在大量增删改查逻辑，会导致大量的的diff可以检查列表元素是否存在唯一的key，通过key可以让React复用Fiber从而避免重复创建 Fiber节点与 Dom 节点<br>\nf). 存在未清除掉的定时器或dom监听事件</li>\n</ol>","author":{"login":"jerry-lllman","avatarUrl":"https://avatars.githubusercontent.com/u/45385120?u=4ddfba34a051c4b37f7b6fdfd0c5290715e510e7&v=4","url":"https://github.com/jerry-lllman"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85ADtfu","bodyHTML":"<p dir=\"auto\">首先是产生在交互上，此时应用明显已加载<br>\n所以可以定位到问题发生于： 用户产生交互之后，  用户接收反馈之前。<br>\n问题的性质属于： 部分操作堵塞了页面的渲染，帧率下降，需要检查js代码。</p>\n<ol dir=\"auto\">\n<li>从流程上，查看是否有不必要的hook导致多次的更新，查看effect回调中是否产生多次重复的开销，能否进行合并，</li>\n<li>数据流向上，是否影响到了其他组件的不必要的更新，配合memo等做一层优化。</li>\n<li>代码习惯上，是否在组件内频繁的声明大量数据，可以配合useMemo,useCallback等 或者将这些数据抽离到外部减少不必要的重复声明</li>\n<li>数据体量上，如果交互后需要与大量数据进行计算导致堵塞，那么能否拆分数据减小计算，或者能否优化时间复杂度。</li>\n</ol>","author":{"login":"0753Ljuc","avatarUrl":"https://avatars.githubusercontent.com/u/59270826?u=e3f961f6debc1ef11b75f1c4af28b6c012c4ef34&v=4","url":"https://github.com/0753Ljuc"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85ADwAq","bodyHTML":"<ol dir=\"auto\">\n<li>首先通过 <strong>Network</strong> 面板确定是否是因为接口阻塞导致页面渲染慢。</li>\n<li>确定渲染问题之后再观察页面是否出现长列表等DOM数量特别大的情况，适当的采用 <strong>虚拟列表</strong> 渲染该元素集合。</li>\n<li>然后再通过 react-dev-tools 的  \"Highlight updates when components render\" 功能查看是否存在 <strong>没有必要的 render</strong> 。</li>\n<li>针对没有必要的render可以采用常用的优化手段：shouldComponentUpdate、PureComponent、useCallback、useMemo、避免key重复、children props等。</li>\n</ol>\n<p dir=\"auto\">通过上述简单的人为手段初步排查后，接下来使用工具来进一步排查。</p>\n<ol start=\"5\" dir=\"auto\">\n<li>使用 react-dev-tools 的 <strong>Profile</strong> 功能，可以清晰的了解到每个组件的<strong>渲染时间</strong>，也可以通过渲染时间维度对组件进行<strong>排序</strong>。针对异常组件再进行观察和优化。</li>\n<li>使用 chrome performance 进一步查看 js 的执行，通过火焰图来查看 <strong>帧率和调用栈</strong> ，针对异常的部分进行排查优化。</li>\n<li>chrome 提供的performance 和 Memory 工具同样也支持 <strong>内存泄漏</strong> 的排查，当通过任务管理器发现页面的内存越来越大不存在减少时，也可通过这些工具来排查内存泄漏的问题。</li>\n</ol>","author":{"login":"EastblueOkay","avatarUrl":"https://avatars.githubusercontent.com/u/13050584?u=3c671ad945c2ba65fa7c920489c7b91e6587c098&v=4","url":"https://github.com/EastblueOkay"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AD_GH","bodyHTML":"<h3 dir=\"auto\">问题排查</h3>\n<p dir=\"auto\">通过 <strong>React Developer Tools</strong> 的 <strong>Profiler</strong> 分析你的 React 应用，然后根据分析结果的 <strong>FlameGraph（火焰图）</strong> 或 <strong>Ranked（渲染排名）</strong> 去定位出现性能问题的组件。我们需要关注 <strong>组件渲染时长</strong> 和 <strong>组件渲染次数</strong> 这两个参数。如果一个组件的渲染次数过多，我们还需要通过 Render 信息窗口中的 <strong>Why did this render?</strong> 查看组件多次渲染的原因，看一看是否是组件需要渲染的状态更新引发的渲染（如果不是的话则组件的渲染为 <strong>非必要重新渲染</strong>）。</p>\n<h3 dir=\"auto\">解决方案</h3>\n<p dir=\"auto\">如果问题的原因是<strong>组件单次渲染时间过长</strong>，我们可以用过以下方式优化：</p>\n<ol dir=\"auto\">\n<li>使用 <code class=\"notranslate\">useMemo</code> 对组件内部昂贵的计算进行缓存，避免组件更新时重复的计算。</li>\n<li>对于经常增删或者交换的元素，为其添加唯一的 <code class=\"notranslate\">key</code> 属性，避免其在 Dom Diff 的过程中被重新创建。</li>\n<li>对于应用中出现长列表等 DOM 元素过多的情况，我们可以使用<strong>虚拟列表</strong>技术，只渲染部分 DOM 节点。</li>\n</ol>\n<p dir=\"auto\">如果问题的原因是<strong>组件非必要重新渲染</strong>，可以通过以下方式优化：</p>\n<ol dir=\"auto\">\n<li>如果组件的 <code class=\"notranslate\">props</code> 没有发生改变，我们可以使用 <code class=\"notranslate\">React.memo</code> 包裹组件，避免其父组件更新引发的非必要渲染。</li>\n<li>如果组件的 <code class=\"notranslate\">props</code> 发生了改变，我们可以追溯其 <code class=\"notranslate\">props</code> 的源头，如果是回调函数，我们可以使用 <code class=\"notranslate\">useCallback</code> 包裹，避免函数引用改变所引发的重渲染。</li>\n</ol>","author":{"login":"wuwenbang","avatarUrl":"https://avatars.githubusercontent.com/u/64624463?u=40fbf3d5a9bfed590006b6025ed2a32a34fc16a1&v=4","url":"https://github.com/wuwenbang"},"replies":null}}]}}},"pageContext":{"number":3,"previous":{"title":"实现 add(1)(2)(3)(4) = 10","number":2},"next":{"title":"首屏渲染白屏时间如何优化？","number":4}}},
    "staticQueryHashes": ["151096407","2861350382"]}