{
    "componentChunkName": "component---src-templates-issues-tsx",
    "path": "/issues/4",
    "result": {"data":{"issuesJson":{"id":"61c88a82-096d-5914-8c6f-bfe42dc0d78e","title":"首屏渲染白屏时间如何优化？","number":4,"bodyHTML":"<h2 dir=\"auto\">问题描述</h2>\n\n\n<p dir=\"auto\">接用户反馈，你司网站<code class=\"notranslate\">首次进入</code>到<code class=\"notranslate\">内容出现</code>间会有一段不小的<code class=\"notranslate\">白屏时间</code>。该网站是用<code class=\"notranslate\">前端框架</code>开发的<code class=\"notranslate\">CSR</code>（Client Side Rendering，客户端渲染）应用，请以如下顺序回答：</p>\n<ol dir=\"auto\">\n<li>如何分析首屏加载CSR的性能？</li>\n<li>分析后如何找出CSR性能瓶颈？</li>\n<li>如何解决CSR性能瓶颈？</li>\n<li>有没有其他渲染方案可以解决CSR当前问题，他的原理是什么？</li>\n</ol>\n<h2 dir=\"auto\">最佳答案</h2>\n<p dir=\"auto\"><a href=\"https://github.com/BetaSu/fe-hunter/issues/4#issuecomment-1075856575\" data-hovercard-type=\"issue\" data-hovercard-url=\"/BetaSu/fe-hunter/issues/4/hovercard\">jerry-lllman的回答</a></p>\n<h3 dir=\"auto\">答题同学须知</h3>\n<p dir=\"auto\">最佳答案由<code class=\"notranslate\">围观同学</code>的<code class=\"notranslate\">👍</code>和<a href=\"https://github.com/BetaSu\">卡颂</a>共同决定。<strong>非答题相关评论</strong>会被删除，问题相关内容讨论请在<a href=\"https://github.com/BetaSu/fe-hunter\">赏金猎人群</a>里讨论</p>\n<h3 dir=\"auto\">围观同学须知</h3>\n<p dir=\"auto\">对于你满意的答案，请不要吝惜你的<code class=\"notranslate\">👍</code>，这是评选<strong>最佳答案</strong>的标准</p>","updatedAt":"2022-03-24T12:40:17Z","upvoteCount":null,"author":{"login":"BetaSu","avatarUrl":"https://avatars.githubusercontent.com/u/15828041?u=3b08cdf9f9b49dbead9ffb020a94d925904d2b74&v=4","url":"https://github.com/BetaSu"},"category":null,"labels":{"edges":[{"node":{"name":"JS","color":"ffee58"}},{"node":{"name":"HTML","color":"66bb6a"}},{"node":{"name":"React","color":"fbc02d"}},{"node":{"name":"Vue","color":"fdd835"}},{"node":{"name":"性能优化","color":"CCEC29"}},{"node":{"name":"场景","color":"2196f3"}}]},"comments":{"edges":[{"node":{"id":"IC_kwDOHCfdf85AH7kl","bodyHTML":"<p dir=\"auto\">先说情况。csr 的首屏加载时间过长一直都是痛点,本体并无 ssr 需求,所以 ssr 相关的解决方案也不会提供。让我们先分析为什么你的网站白屏时间那么久</p>\n<h3 dir=\"auto\">为什么会白屏</h3>\n<p dir=\"auto\">这是一个老生常谈的问题无非离不开资源过大,加载方式不合理,以及 csr 本身的瓶颈以及服务器的配置相关。这里我将从这几个维度给出我个人的解决方案。各位可以酌情考虑纳入适用范围。</p>\n<h4 dir=\"auto\">服务器与 CDN 的解决方式</h4>\n<p dir=\"auto\">合理的配置资源缓存方式,以及选用靠谱的 CDN 服务。服务端启用<code class=\"notranslate\">gzip</code>等压缩模式压缩这些静态资源加快传输</p>\n<h4 dir=\"auto\">静态资源优化</h4>\n<p dir=\"auto\">关于 gzip 压缩这些是老生常谈的话题这里也不再赘述，就从几个压缩工具谈谈我个人的感受,css 角度上我会倾向于使用<code class=\"notranslate\">clean-css</code>他的压缩效率是很高的相较于<code class=\"notranslate\">css-nao</code>依附于<code class=\"notranslate\">postcss</code>生态而言,再从图片压缩的角度来看<code class=\"notranslate\">tinypng</code>也是一样的。</p>\n<p dir=\"auto\">减少静态资源的体积。压缩静态资源其实是一种<code class=\"notranslate\">footgun</code>与其思考压缩体积。不如从源头上解决开发这些的方式,比如采用原子化 css 或者<code class=\"notranslate\">css in js</code>减少 css 文件的占用比。更小的 css 不仅减少了流量的传输,由于浏览器不需要在解析无用的 css rule 渲染性能的提升也是显而易见的。</p>\n<p dir=\"auto\">明确你的图片宽高也就是<code class=\"notranslate\">width</code>和<code class=\"notranslate\">hegiht</code>属性,这样可以避免图片响应造成的<code class=\"notranslate\">layout shift</code>。</p>\n<p dir=\"auto\">当我们完成了静态资源的压缩,以什么顺序进行发送呈现给用户是极其重要的。本次答题的重点还是得契合<code class=\"notranslate\">首屏资源加载的体验</code>,那么我们就得避免<code class=\"notranslate\">Blocking script</code>阻塞页面的渲染和加载，所以在我们加载这些<code class=\"notranslate\">script</code>的时候我们应该把一些不重要的脚本异步加载,确保首屏资源的最高优先级，对于直接影响渲染的<code class=\"notranslate\">script</code>例如(<code class=\"notranslate\">dark mod</code>)我们则应该把他们内联到 html 的<code class=\"notranslate\">&lt;head /&gt;</code>中，这样他就会在<code class=\"notranslate\">Parser HTML</code>的阶段执行啦。媒体资源例如图片等我们就需要做<code class=\"notranslate\">lazy-load</code>这样我们就能保证在不同浏览器上我们优先加载的资源只有<code class=\"notranslate\">html</code>和<code class=\"notranslate\">css</code>,不论浏览器如何为其分配带宽和优先级都不会显著的影响白屏时间。</p>\n<h4 dir=\"auto\">脚本的加载执行</h4>\n<p dir=\"auto\">延迟非关键资源的加载，加速<code class=\"notranslate\">css</code>传送。我们可以在服务端启用<code class=\"notranslate\">http2</code>加速资源的发送这样我们就可以节省一个<code class=\"notranslate\">RTT</code>达到更快的解析渲染,确保第三方资源<code class=\"notranslate\">javascript</code>的异步加载。比如你在使用<code class=\"notranslate\">element</code>,<code class=\"notranslate\">antd</code>这些 cdn 资源我们应该在<code class=\"notranslate\">&lt;script /&gt;</code>上设置<code class=\"notranslate\">async</code>。什么你不知道<code class=\"notranslate\">async</code>和<code class=\"notranslate\">defer</code>？<code class=\"notranslate\">defer</code>就是上文说到的<code class=\"notranslate\">blocking script</code>，<code class=\"notranslate\">async</code>就是当 HTML 解析到开始加载他是无视<code class=\"notranslate\">DOM</code>和渲染以及<code class=\"notranslate\">onload</code>的。而现代浏览器的正确做法应该是使用<code class=\"notranslate\">DOM</code>动态创建<code class=\"notranslate\">script async</code>标签去加载资源。<br>\n现有大部分的框架以及<code class=\"notranslate\">bundle</code>工具都支持切割代码我们可以把这些资源都切割保证首屏的<code class=\"notranslate\">js</code>足够轻量级。</p>\n<h4 dir=\"auto\">优化你的 css</h4>\n<p dir=\"auto\">优化你的 css 选择器。css 的渲染取决于一组匹配选择器 不合理的选择器会导致解析过慢,css 选择器的解析顺序是从右到左，所以在面对复杂的 css 场景我们应该根据<code class=\"notranslate\">Steve Souders</code>大师总结的<code class=\"notranslate\">css</code>选择器性能排行合理的选择方案达到更快的解析以及渲染。</p>\n<h4 dir=\"auto\">采用 SSR(同构渲染)</h4>\n<p dir=\"auto\">上述是通用的资源响应解决手段。但是<code class=\"notranslate\">csr</code>总归是有作为<code class=\"notranslate\">csr</code>的局限性。这时候我们就得回归本质<code class=\"notranslate\">ssr</code>在服务端解析出了所有的<code class=\"notranslate\">dom</code>生成了<code class=\"notranslate\">string</code>这样在访问的时候和<code class=\"notranslate\">csr</code>需要解析在合成渲染是截然不同的,现代的<code class=\"notranslate\">ssr</code>框架允许模块采用<code class=\"notranslate\">csr</code>加载我们可以在首屏重要的部分进行<code class=\"notranslate\">ssr</code>其他采用<code class=\"notranslate\">csr</code>。合理的搭配我们的渲染结构。</p>","author":{"login":"nonzzz","avatarUrl":"https://avatars.githubusercontent.com/u/52351095?u=6f6f36a4ced0620abe20704520835a1fdf67fef2&v=4","url":"https://github.com/nonzzz"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AIChN","bodyHTML":"<blockquote>\n<p dir=\"auto\">先说情况。csr 的首屏加载时间过长一直都是痛点,本体并无 ssr 需求,所以 ssr 相关的解决方案也不会提供。让我们先分析为什么你的网站白屏时间那么久</p>\n<h3 dir=\"auto\">为什么会白屏</h3>\n<p dir=\"auto\">这是一个老生常谈的问题无非离不开资源过大,加载方式不合理,以及 csr 本身的瓶颈以及服务器的配置相关。这里我将从这几个维度给出我个人的解决方案。各位可以酌情考虑纳入适用范围。</p>\n<h4 dir=\"auto\">服务器与 CDN 的解决方式</h4>\n<p dir=\"auto\">合理的配置资源缓存方式,以及选用靠谱的 CDN 服务。服务端启用<code class=\"notranslate\">gzip</code>等压缩模式压缩这些静态资源加快传输</p>\n<h4 dir=\"auto\">静态资源优化</h4>\n<p dir=\"auto\">关于 gzip 压缩这些是老生常谈的话题这里也不再赘述，就从几个压缩工具谈谈我个人的感受,css 角度上我会倾向于使用<code class=\"notranslate\">clean-css</code>他的压缩效率是很高的相较于<code class=\"notranslate\">css-nao</code>依附于<code class=\"notranslate\">postcss</code>生态而言,再从图片压缩的角度来看<code class=\"notranslate\">tinypng</code>也是一样的。</p>\n<p dir=\"auto\">减少静态资源的体积。压缩静态资源其实是一种<code class=\"notranslate\">footgun</code>与其思考压缩体积。不如从源头上解决开发这些的方式,比如采用原子化 css 或者<code class=\"notranslate\">css in js</code>减少 css 文件的占用比。更小的 css 不仅减少了流量的传输,由于浏览器不需要在解析无用的 css rule 渲染性能的提升也是显而易见的。</p>\n<p dir=\"auto\">明确你的图片宽高也就是<code class=\"notranslate\">width</code>和<code class=\"notranslate\">hegiht</code>属性,这样可以避免图片响应造成的<code class=\"notranslate\">layout shift</code>。</p>\n<p dir=\"auto\">当我们完成了静态资源的压缩,以什么顺序进行发送呈现给用户是极其重要的。本次答题的重点还是得契合<code class=\"notranslate\">首屏资源加载的体验</code>,那么我们就得避免<code class=\"notranslate\">Blocking script</code>阻塞页面的渲染和加载，所以在我们加载这些<code class=\"notranslate\">script</code>的时候我们应该把一些不重要的脚本异步加载,确保首屏资源的最高优先级，对于直接影响渲染的<code class=\"notranslate\">script</code>例如(<code class=\"notranslate\">dark mod</code>)我们则应该把他们内联到 html 的<code class=\"notranslate\">&lt;head /&gt;</code>中，这样他就会在<code class=\"notranslate\">Parser HTML</code>的阶段执行啦。媒体资源例如图片等我们就需要做<code class=\"notranslate\">lazy-load</code>这样我们就能保证在不同浏览器上我们优先加载的资源只有<code class=\"notranslate\">html</code>和<code class=\"notranslate\">css</code>,不论浏览器如何为其分配带宽和优先级都不会显著的影响白屏时间。</p>\n<h4 dir=\"auto\">脚本的加载执行</h4>\n<p dir=\"auto\">延迟非关键资源的加载，加速<code class=\"notranslate\">css</code>传送。我们可以在服务端启用<code class=\"notranslate\">http2</code>加速资源的发送这样我们就可以节省一个<code class=\"notranslate\">RTT</code>达到更快的解析渲染,确保第三方资源<code class=\"notranslate\">javascript</code>的异步加载。比如你在使用<code class=\"notranslate\">element</code>,<code class=\"notranslate\">antd</code>这些 cdn 资源我们应该在<code class=\"notranslate\">&lt;script /&gt;</code>上设置<code class=\"notranslate\">async</code>。什么你不知道<code class=\"notranslate\">async</code>和<code class=\"notranslate\">defer</code>？<code class=\"notranslate\">defer</code>就是上文说到的<code class=\"notranslate\">blocking script</code>，<code class=\"notranslate\">async</code>就是当 HTML 解析到开始加载他是无视<code class=\"notranslate\">DOM</code>和渲染以及<code class=\"notranslate\">onload</code>的。而现代浏览器的正确做法应该是使用<code class=\"notranslate\">DOM</code>动态创建<code class=\"notranslate\">script async</code>标签去加载资源。 现有大部分的框架以及<code class=\"notranslate\">bundle</code>工具都支持切割代码我们可以把这些资源都切割保证首屏的<code class=\"notranslate\">js</code>足够轻量级。</p>\n<h4 dir=\"auto\">优化你的 css</h4>\n<p dir=\"auto\">优化你的 css 选择器。css 的渲染取决于一组匹配选择器 不合理的选择器会导致解析过慢,css 选择器的解析顺序是从右到左，所以在面对复杂的 css 场景我们应该根据<code class=\"notranslate\">Steve Souders</code>大师总结的<code class=\"notranslate\">css</code>选择器性能排行合理的选择方案达到更快的解析以及渲染。</p>\n<h4 dir=\"auto\">采用 SSR(同构渲染)</h4>\n<p dir=\"auto\">上述是通用的资源响应解决手段。但是<code class=\"notranslate\">csr</code>总归是有作为<code class=\"notranslate\">csr</code>的局限性。这时候我们就得回归本质<code class=\"notranslate\">ssr</code>在服务端解析出了所有的<code class=\"notranslate\">dom</code>生成了<code class=\"notranslate\">string</code>这样在访问的时候和<code class=\"notranslate\">csr</code>需要解析在合成渲染是截然不同的,现代的<code class=\"notranslate\">ssr</code>框架允许模块采用<code class=\"notranslate\">csr</code>加载我们可以在首屏重要的部分进行<code class=\"notranslate\">ssr</code>其他采用<code class=\"notranslate\">csr</code>。合理的搭配我们的渲染结构。</p>\n</blockquote>\n<p dir=\"auto\">“defer就是上文说到的blocking script” defer怎么会是blocking script？</p>","author":{"login":"shenzhim","avatarUrl":"https://avatars.githubusercontent.com/u/12244144?u=54329039e3dca896c03b67466cfd71729abb0430&v=4","url":"https://github.com/shenzhim"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AICsp","bodyHTML":"<blockquote>\n<blockquote>\n<p dir=\"auto\">先说情况。csr 的首屏加载时间过长一直都是痛点,本体并无 ssr 需求,所以 ssr 相关的解决方案也不会提供。让我们先分析为什么你的网站白屏时间那么久</p>\n<h3 dir=\"auto\">为什么会白屏</h3>\n<p dir=\"auto\">这是一个老生常谈的问题无非离不开资源过大,加载方式不合理,以及 csr 本身的瓶颈以及服务器的配置相关。这里我将从这几个维度给出我个人的解决方案。各位可以酌情考虑纳入适用范围。</p>\n<h4 dir=\"auto\">服务器与 CDN 的解决方式</h4>\n<p dir=\"auto\">合理的配置资源缓存方式,以及选用靠谱的 CDN 服务。服务端启用<code class=\"notranslate\">gzip</code>等压缩模式压缩这些静态资源加快传输</p>\n<h4 dir=\"auto\">静态资源优化</h4>\n<p dir=\"auto\">关于 gzip 压缩这些是老生常谈的话题这里也不再赘述，就从几个压缩工具谈谈我个人的感受,css 角度上我会倾向于使用<code class=\"notranslate\">clean-css</code>他的压缩效率是很高的相较于<code class=\"notranslate\">css-nao</code>依附于<code class=\"notranslate\">postcss</code>生态而言,再从图片压缩的角度来看<code class=\"notranslate\">tinypng</code>也是一样的。<br>\n减少静态资源的体积。压缩静态资源其实是一种<code class=\"notranslate\">footgun</code>与其思考压缩体积。不如从源头上解决开发这些的方式,比如采用原子化 css 或者<code class=\"notranslate\">css in js</code>减少 css 文件的占用比。更小的 css 不仅减少了流量的传输,由于浏览器不需要在解析无用的 css rule 渲染性能的提升也是显而易见的。<br>\n明确你的图片宽高也就是<code class=\"notranslate\">width</code>和<code class=\"notranslate\">hegiht</code>属性,这样可以避免图片响应造成的<code class=\"notranslate\">layout shift</code>。<br>\n当我们完成了静态资源的压缩,以什么顺序进行发送呈现给用户是极其重要的。本次答题的重点还是得契合<code class=\"notranslate\">首屏资源加载的体验</code>,那么我们就得避免<code class=\"notranslate\">Blocking script</code>阻塞页面的渲染和加载，所以在我们加载这些<code class=\"notranslate\">script</code>的时候我们应该把一些不重要的脚本异步加载,确保首屏资源的最高优先级，对于直接影响渲染的<code class=\"notranslate\">script</code>例如(<code class=\"notranslate\">dark mod</code>)我们则应该把他们内联到 html 的<code class=\"notranslate\">&lt;head /&gt;</code>中，这样他就会在<code class=\"notranslate\">Parser HTML</code>的阶段执行啦。媒体资源例如图片等我们就需要做<code class=\"notranslate\">lazy-load</code>这样我们就能保证在不同浏览器上我们优先加载的资源只有<code class=\"notranslate\">html</code>和<code class=\"notranslate\">css</code>,不论浏览器如何为其分配带宽和优先级都不会显著的影响白屏时间。</p>\n<h4 dir=\"auto\">脚本的加载执行</h4>\n<p dir=\"auto\">延迟非关键资源的加载，加速<code class=\"notranslate\">css</code>传送。我们可以在服务端启用<code class=\"notranslate\">http2</code>加速资源的发送这样我们就可以节省一个<code class=\"notranslate\">RTT</code>达到更快的解析渲染,确保第三方资源<code class=\"notranslate\">javascript</code>的异步加载。比如你在使用<code class=\"notranslate\">element</code>,<code class=\"notranslate\">antd</code>这些 cdn 资源我们应该在<code class=\"notranslate\">&lt;script /&gt;</code>上设置<code class=\"notranslate\">async</code>。什么你不知道<code class=\"notranslate\">async</code>和<code class=\"notranslate\">defer</code>？<code class=\"notranslate\">defer</code>就是上文说到的<code class=\"notranslate\">blocking script</code>，<code class=\"notranslate\">async</code>就是当 HTML 解析到开始加载他是无视<code class=\"notranslate\">DOM</code>和渲染以及<code class=\"notranslate\">onload</code>的。而现代浏览器的正确做法应该是使用<code class=\"notranslate\">DOM</code>动态创建<code class=\"notranslate\">script async</code>标签去加载资源。 现有大部分的框架以及<code class=\"notranslate\">bundle</code>工具都支持切割代码我们可以把这些资源都切割保证首屏的<code class=\"notranslate\">js</code>足够轻量级。</p>\n<h4 dir=\"auto\">优化你的 css</h4>\n<p dir=\"auto\">优化你的 css 选择器。css 的渲染取决于一组匹配选择器 不合理的选择器会导致解析过慢,css 选择器的解析顺序是从右到左，所以在面对复杂的 css 场景我们应该根据<code class=\"notranslate\">Steve Souders</code>大师总结的<code class=\"notranslate\">css</code>选择器性能排行合理的选择方案达到更快的解析以及渲染。</p>\n<h4 dir=\"auto\">采用 SSR(同构渲染)</h4>\n<p dir=\"auto\">上述是通用的资源响应解决手段。但是<code class=\"notranslate\">csr</code>总归是有作为<code class=\"notranslate\">csr</code>的局限性。这时候我们就得回归本质<code class=\"notranslate\">ssr</code>在服务端解析出了所有的<code class=\"notranslate\">dom</code>生成了<code class=\"notranslate\">string</code>这样在访问的时候和<code class=\"notranslate\">csr</code>需要解析在合成渲染是截然不同的,现代的<code class=\"notranslate\">ssr</code>框架允许模块采用<code class=\"notranslate\">csr</code>加载我们可以在首屏重要的部分进行<code class=\"notranslate\">ssr</code>其他采用<code class=\"notranslate\">csr</code>。合理的搭配我们的渲染结构。</p>\n</blockquote>\n<p dir=\"auto\">“defer就是上文说到的blocking script” defer怎么会是blocking script？</p>\n</blockquote>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://user-images.githubusercontent.com/52351095/159611909-95c162c6-0c23-4487-a1f9-f44139586f68.png\"><img src=\"https://user-images.githubusercontent.com/52351095/159611909-95c162c6-0c23-4487-a1f9-f44139586f68.png\" alt=\"image\" style=\"max-width: 100%;\"></a><br>\nMDN请<br>\n这里解释下为什么他还是<code class=\"notranslate\">blocking script</code>因为<code class=\"notranslate\">domXXX</code>事件被阻塞了。</p>","author":{"login":"nonzzz","avatarUrl":"https://avatars.githubusercontent.com/u/52351095?u=6f6f36a4ced0620abe20704520835a1fdf67fef2&v=4","url":"https://github.com/nonzzz"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AIEL1","bodyHTML":"<blockquote>\n<blockquote>\n<blockquote>\n<p dir=\"auto\">先说情况。csr 的首屏加载时间过长一直都是痛点,本体并无 ssr 需求,所以 ssr 相关的解决方案也不会提供。让我们先分析为什么你的网站白屏时间那么久</p>\n<h3 dir=\"auto\">为什么会白屏</h3>\n<p dir=\"auto\">这是一个老生常谈的问题无非离不开资源过大,加载方式不合理,以及 csr 本身的瓶颈以及服务器的配置相关。这里我将从这几个维度给出我个人的解决方案。各位可以酌情考虑纳入适用范围。</p>\n<h4 dir=\"auto\">服务器与 CDN 的解决方式</h4>\n<p dir=\"auto\">合理的配置资源缓存方式,以及选用靠谱的 CDN 服务。服务端启用<code class=\"notranslate\">gzip</code>等压缩模式压缩这些静态资源加快传输</p>\n<h4 dir=\"auto\">静态资源优化</h4>\n<p dir=\"auto\">关于 gzip 压缩这些是老生常谈的话题这里也不再赘述，就从几个压缩工具谈谈我个人的感受,css 角度上我会倾向于使用<code class=\"notranslate\">clean-css</code>他的压缩效率是很高的相较于<code class=\"notranslate\">css-nao</code>依附于<code class=\"notranslate\">postcss</code>生态而言,再从图片压缩的角度来看<code class=\"notranslate\">tinypng</code>也是一样的。<br>\n减少静态资源的体积。压缩静态资源其实是一种<code class=\"notranslate\">footgun</code>与其思考压缩体积。不如从源头上解决开发这些的方式,比如采用原子化 css 或者<code class=\"notranslate\">css in js</code>减少 css 文件的占用比。更小的 css 不仅减少了流量的传输,由于浏览器不需要在解析无用的 css rule 渲染性能的提升也是显而易见的。<br>\n明确你的图片宽高也就是<code class=\"notranslate\">width</code>和<code class=\"notranslate\">hegiht</code>属性,这样可以避免图片响应造成的<code class=\"notranslate\">layout shift</code>。<br>\n当我们完成了静态资源的压缩,以什么顺序进行发送呈现给用户是极其重要的。本次答题的重点还是得契合<code class=\"notranslate\">首屏资源加载的体验</code>,那么我们就得避免<code class=\"notranslate\">Blocking script</code>阻塞页面的渲染和加载，所以在我们加载这些<code class=\"notranslate\">script</code>的时候我们应该把一些不重要的脚本异步加载,确保首屏资源的最高优先级，对于直接影响渲染的<code class=\"notranslate\">script</code>例如(<code class=\"notranslate\">dark mod</code>)我们则应该把他们内联到 html 的<code class=\"notranslate\">&lt;head /&gt;</code>中，这样他就会在<code class=\"notranslate\">Parser HTML</code>的阶段执行啦。媒体资源例如图片等我们就需要做<code class=\"notranslate\">lazy-load</code>这样我们就能保证在不同浏览器上我们优先加载的资源只有<code class=\"notranslate\">html</code>和<code class=\"notranslate\">css</code>,不论浏览器如何为其分配带宽和优先级都不会显著的影响白屏时间。</p>\n<h4 dir=\"auto\">脚本的加载执行</h4>\n<p dir=\"auto\">延迟非关键资源的加载，加速<code class=\"notranslate\">css</code>传送。我们可以在服务端启用<code class=\"notranslate\">http2</code>加速资源的发送这样我们就可以节省一个<code class=\"notranslate\">RTT</code>达到更快的解析渲染,确保第三方资源<code class=\"notranslate\">javascript</code>的异步加载。比如你在使用<code class=\"notranslate\">element</code>,<code class=\"notranslate\">antd</code>这些 cdn 资源我们应该在<code class=\"notranslate\">&lt;script /&gt;</code>上设置<code class=\"notranslate\">async</code>。什么你不知道<code class=\"notranslate\">async</code>和<code class=\"notranslate\">defer</code>？<code class=\"notranslate\">defer</code>就是上文说到的<code class=\"notranslate\">blocking script</code>，<code class=\"notranslate\">async</code>就是当 HTML 解析到开始加载他是无视<code class=\"notranslate\">DOM</code>和渲染以及<code class=\"notranslate\">onload</code>的。而现代浏览器的正确做法应该是使用<code class=\"notranslate\">DOM</code>动态创建<code class=\"notranslate\">script async</code>标签去加载资源。 现有大部分的框架以及<code class=\"notranslate\">bundle</code>工具都支持切割代码我们可以把这些资源都切割保证首屏的<code class=\"notranslate\">js</code>足够轻量级。</p>\n<h4 dir=\"auto\">优化你的 css</h4>\n<p dir=\"auto\">优化你的 css 选择器。css 的渲染取决于一组匹配选择器 不合理的选择器会导致解析过慢,css 选择器的解析顺序是从右到左，所以在面对复杂的 css 场景我们应该根据<code class=\"notranslate\">Steve Souders</code>大师总结的<code class=\"notranslate\">css</code>选择器性能排行合理的选择方案达到更快的解析以及渲染。</p>\n<h4 dir=\"auto\">采用 SSR(同构渲染)</h4>\n<p dir=\"auto\">上述是通用的资源响应解决手段。但是<code class=\"notranslate\">csr</code>总归是有作为<code class=\"notranslate\">csr</code>的局限性。这时候我们就得回归本质<code class=\"notranslate\">ssr</code>在服务端解析出了所有的<code class=\"notranslate\">dom</code>生成了<code class=\"notranslate\">string</code>这样在访问的时候和<code class=\"notranslate\">csr</code>需要解析在合成渲染是截然不同的,现代的<code class=\"notranslate\">ssr</code>框架允许模块采用<code class=\"notranslate\">csr</code>加载我们可以在首屏重要的部分进行<code class=\"notranslate\">ssr</code>其他采用<code class=\"notranslate\">csr</code>。合理的搭配我们的渲染结构。</p>\n</blockquote>\n<p dir=\"auto\">“defer就是上文说到的blocking script” defer怎么会是blocking script？</p>\n</blockquote>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://user-images.githubusercontent.com/52351095/159611909-95c162c6-0c23-4487-a1f9-f44139586f68.png\"><img src=\"https://user-images.githubusercontent.com/52351095/159611909-95c162c6-0c23-4487-a1f9-f44139586f68.png\" alt=\"image\" style=\"max-width: 100%;\"></a> MDN请 这里解释下为什么他还是<code class=\"notranslate\">blocking script</code>因为<code class=\"notranslate\">domXXX</code>事件被阻塞了。</p>\n</blockquote>\n<p dir=\"auto\">blocking script 的概念应该是阻塞dom的渲染吧</p>","author":{"login":"shenzhim","avatarUrl":"https://avatars.githubusercontent.com/u/12244144?u=54329039e3dca896c03b67466cfd71729abb0430&v=4","url":"https://github.com/shenzhim"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AIES_","bodyHTML":"<p dir=\"auto\">对于其他同学回答过的部分我就不展开讲了，我主要讲大体的思路。</p>\n<p dir=\"auto\">一、如何分析首屏加载CSR的性能？<br>\n有三种方式进行分析：</p>\n<ol dir=\"auto\">\n<li>network（浏览器-&gt;DevTools）</li>\n<li>performance （浏览器-&gt;DevTools）</li>\n<li>lighthouse（浏览器-&gt;DevTools）</li>\n<li>sentry（第三方平台）</li>\n<li><a href=\"https://webpagetest.org/\" rel=\"nofollow\"><strong>webPageTest</strong></a> 更全面，更详细，更强大的页面分析<br>\n具体怎么操作我就不赘述了，各位自行去看。</li>\n</ol>\n<p dir=\"auto\">二、分析后如何找出CSR性能瓶颈？<br>\n按照上面的5种方式来看吧</p>\n<p dir=\"auto\">三、如何解决CSR性能瓶颈？<br>\n从CSR方向来讲的话，基本就两个方向了</p>\n<ol dir=\"auto\">\n<li>\n<p dir=\"auto\"><strong>网络层面</strong>：<br>\n从网络方面来讲，就是减少HTTP请求的次数，以及减小请求体积，这里就简单聊几点<br>\na). 将多次请求合并到一次请求（ajax、精灵图，文件合并等）<br>\nb). 页面懒加载应该也可以算在这个方面。<br>\nc). 缓存住一些不经常改动的文件或内容将请求拦截（service worker）<br>\nb). 文件内容压缩<br>\ne). 静态资源CDN也是方式之一<br>\nf). 升级到 http2</p>\n</li>\n<li>\n<p dir=\"auto\"><strong>渲染层面</strong><br>\na). 骨架屏，起码能让用户有打开了网页的感觉<br>\nb). 图片懒加载<br>\nc). 防抖节流<br>\nd). 代码层面的改善吧，很有可能是某些坏代码产生的</p>\n</li>\n</ol>\n<p dir=\"auto\">四、有没有其他渲染方案可以解决CSR当前问题，他的原理是什么？<br>\nSSR。就是将框架代码提前在服务端跑一遍，不过一般除非对SEO要求比较高或者你们公司比较有钱，否则不太会去使用，因为比较占用服务器的资源。</p>","author":{"login":"jerry-lllman","avatarUrl":"https://avatars.githubusercontent.com/u/45385120?u=4ddfba34a051c4b37f7b6fdfd0c5290715e510e7&v=4","url":"https://github.com/jerry-lllman"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AIEl2","bodyHTML":"<p dir=\"auto\"><a href=\"https://developers.google.com/web/fundamentals/performance/get-started\" rel=\"nofollow\">https://developers.google.com/web/fundamentals/performance/get-started</a></p>","author":{"login":"WarrenJones","avatarUrl":"https://avatars.githubusercontent.com/u/8704779?u=0ec88dbbe227fbcd2cbb41f306b40cc07dc68a9d&v=4","url":"https://github.com/WarrenJones"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AIErw","bodyHTML":"<blockquote>\n<p dir=\"auto\">blocking script 的概念应该是阻塞dom的渲染吧<br>\n参见<a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=611136\" rel=\"nofollow\">https://bugs.chromium.org/p/chromium/issues/detail?id=611136</a> 。首先我们要明确<code class=\"notranslate\">DOMContentLoaded</code></p>\n</blockquote>","author":{"login":"nonzzz","avatarUrl":"https://avatars.githubusercontent.com/u/52351095?u=6f6f36a4ced0620abe20704520835a1fdf67fef2&v=4","url":"https://github.com/nonzzz"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AIfgN","bodyHTML":"<blockquote>\n<blockquote>\n<p dir=\"auto\">blocking script 的概念应该是阻塞dom的渲染吧<br>\n参见<a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=611136\" rel=\"nofollow\">https://bugs.chromium.org/p/chromium/issues/detail?id=611136</a> 。首先我们要明确<code class=\"notranslate\">DOMContentLoaded</code></p>\n</blockquote>\n</blockquote>\n<p dir=\"auto\">贴的这个链接，看上去是content type 改为了 application/xhtml+xml导致的问题，看下面的评论说是XMLDocumentLoader不支持defer。<br>\n这个跟 defer是不是 blocking script 没什么关系吧</p>","author":{"login":"shenzhim","avatarUrl":"https://avatars.githubusercontent.com/u/12244144?u=54329039e3dca896c03b67466cfd71729abb0430&v=4","url":"https://github.com/shenzhim"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AIf5x","bodyHTML":"<blockquote>\n<p dir=\"auto\">贴的这个链接，看上去是content type 改为了 application/xhtml+xml导致的问题，看下面的评论说是XMLDocumentLoader不支持defer。 这个跟 defer是不是 blocking script 没什么关系吧</p>\n</blockquote>\n<p dir=\"auto\">因为你DOM完成绘制是要在<code class=\"notranslate\">DOMContentLoaded</code>执行完毕的。而<code class=\"notranslate\">defer</code>会阻塞这一个过程。</p>","author":{"login":"nonzzz","avatarUrl":"https://avatars.githubusercontent.com/u/52351095?u=6f6f36a4ced0620abe20704520835a1fdf67fef2&v=4","url":"https://github.com/nonzzz"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AIiLI","bodyHTML":"<blockquote>\n<blockquote>\n<p dir=\"auto\">贴的这个链接，看上去是content type 改为了 application/xhtml+xml导致的问题，看下面的评论说是XMLDocumentLoader不支持defer。 这个跟 defer是不是 blocking script 没什么关系吧</p>\n</blockquote>\n<p dir=\"auto\">因为你DOM完成绘制是要在<code class=\"notranslate\">DOMContentLoaded</code>执行完毕的。而<code class=\"notranslate\">defer</code>会阻塞这一个过程。</p>\n</blockquote>\n<p dir=\"auto\">确实，defer会阻塞domcontentloaded事件，但是不能说 defer就是一个blocking script。<br>\n阻塞脚本，应该理解成阻塞dom解析，而defer的脚本是不会的</p>","author":{"login":"shenzhim","avatarUrl":"https://avatars.githubusercontent.com/u/12244144?u=54329039e3dca896c03b67466cfd71729abb0430&v=4","url":"https://github.com/shenzhim"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AIidD","bodyHTML":"<blockquote>\n<p dir=\"auto\">确实，defer会阻塞domcontentloaded事件，但是不能说 defer就是一个blocking script。 阻塞脚本，应该理解成阻塞dom解析，而defer的脚本是不会的</p>\n</blockquote>\n<p dir=\"auto\">但是 他和<code class=\"notranslate\">blocking script</code>造成的效果不是一致的吗hh。按照这样理解的话其实<code class=\"notranslate\">defer</code>就不是最佳实践。反倒是动态的create<code class=\"notranslate\">script async</code>才是。我理解为<code class=\"notranslate\">blocking</code>是因为他和<code class=\"notranslate\">blocking</code>是一致性的。</p>","author":{"login":"nonzzz","avatarUrl":"https://avatars.githubusercontent.com/u/52351095?u=6f6f36a4ced0620abe20704520835a1fdf67fef2&v=4","url":"https://github.com/nonzzz"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AIjEu","bodyHTML":"<blockquote>\n<blockquote>\n<p dir=\"auto\">确实，defer会阻塞domcontentloaded事件，但是不能说 defer就是一个blocking script。 阻塞脚本，应该理解成阻塞dom解析，而defer的脚本是不会的</p>\n</blockquote>\n<p dir=\"auto\">但是 他和<code class=\"notranslate\">blocking script</code>造成的效果不是一致的吗hh。按照这样理解的话其实<code class=\"notranslate\">defer</code>就不是最佳实践。反倒是动态的create<code class=\"notranslate\">script async</code>才是。我理解为<code class=\"notranslate\">blocking</code>是因为他和<code class=\"notranslate\">blocking</code>是一致性的。</p>\n</blockquote>\n<p dir=\"auto\">blocking script 会导致dom解析暂停，而 defer script 的下载是不会影响dom解析的。我理解defer的使用场景可以跟preload使用场景一致，defer和async的都不会阻塞dom解析，区别在于js文件加载后的执行顺序不同以及有无对DomContentLoaded的事件影响</p>","author":{"login":"shenzhim","avatarUrl":"https://avatars.githubusercontent.com/u/12244144?u=54329039e3dca896c03b67466cfd71729abb0430&v=4","url":"https://github.com/shenzhim"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AIjWg","bodyHTML":"<blockquote>\n<p dir=\"auto\">blocking script 会导致dom解析暂停，而 defer script 的下载是不会影响dom解析的。我理解defer的使用场景可以跟preload使用场景一致，defer和async的都不会阻塞dom解析，区别在于js文件加载后的执行顺序不同以及有无对DomContentLoaded的事件影响</p>\n</blockquote>\n<p dir=\"auto\">是这样。但往往<code class=\"notranslate\">async</code>才是最佳实践，虽然<code class=\"notranslate\">defer</code>和<code class=\"notranslate\">async</code>近似一样 但是对于解析dom的差异很大。<code class=\"notranslate\">preload</code>确实是有这么个场景。</p>","author":{"login":"nonzzz","avatarUrl":"https://avatars.githubusercontent.com/u/52351095?u=6f6f36a4ced0620abe20704520835a1fdf67fef2&v=4","url":"https://github.com/nonzzz"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AIkPf","bodyHTML":"<blockquote>\n<blockquote>\n<p dir=\"auto\">blocking script 会导致dom解析暂停，而 defer script 的下载是不会影响dom解析的。我理解defer的使用场景可以跟preload使用场景一致，defer和async的都不会阻塞dom解析，区别在于js文件加载后的执行顺序不同以及有无对DomContentLoaded的事件影响</p>\n</blockquote>\n<p dir=\"auto\">是这样。但往往<code class=\"notranslate\">async</code>才是最佳实践，虽然<code class=\"notranslate\">defer</code>和<code class=\"notranslate\">async</code>近似一样 但是对于解析dom的差异很大。<code class=\"notranslate\">preload</code>确实是有这么个场景。</p>\n</blockquote>\n<p dir=\"auto\">不能说async就是一定的最佳实践吧<br>\n还是根据具体情况来的，如果是一些第三方库并且对执行顺序没有要求时（比如说谷歌的analytics脚本）<br>\n如果碰到的场景需要js的执行是需要按照一定的顺序时，使用defer才更合理一点</p>","author":{"login":"shenzhim","avatarUrl":"https://avatars.githubusercontent.com/u/12244144?u=54329039e3dca896c03b67466cfd71729abb0430&v=4","url":"https://github.com/shenzhim"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AIk-l","bodyHTML":"<blockquote>\n<p dir=\"auto\">不能说async就是一定的最佳实践吧 还是根据具体情况来的，如果是一些第三方库并且对执行顺序没有要求时（比如说谷歌的analytics脚本） 如果碰到的场景需要js的执行是需要按照一定的顺序时，使用defer才更合理一点</p>\n</blockquote>\n<p dir=\"auto\">具体情况具体分析了。这里说下分析工具吧<code class=\"notranslate\">web-vitals</code>这个库很棒。可以配合<code class=\"notranslate\">performance</code>使用</p>","author":{"login":"nonzzz","avatarUrl":"https://avatars.githubusercontent.com/u/52351095?u=6f6f36a4ced0620abe20704520835a1fdf67fef2&v=4","url":"https://github.com/nonzzz"},"replies":null}}]}}},"pageContext":{"number":4,"previous":{"title":"React应用卡顿该如何排查？","number":3},"next":{"title":"如何应对产品经理中途改需求？","number":5}}},
    "staticQueryHashes": ["151096407","2861350382"]}