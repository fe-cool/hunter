{
    "componentChunkName": "component---src-templates-issues-tsx",
    "path": "/issues/1",
    "result": {"data":{"issuesJson":{"id":"52abd4ae-73fe-5561-9d61-4da5111e073f","title":"如何排查webpack打包产物大的问题？","number":1,"bodyHTML":"<h2 dir=\"auto\">问题描述</h2>\n\n\n<p dir=\"auto\">在<code class=\"notranslate\">DEV</code>环境开发时，发现<code class=\"notranslate\">webpack</code>打包用时很长，打包产物大，如何定位并解决这个问题，请说出详细步骤</p>\n<h2 dir=\"auto\">最佳答案</h2>\n<p dir=\"auto\"><a href=\"https://github.com/BetaSu/fe-hunter/issues/1#issuecomment-1074746441\" data-hovercard-type=\"issue\" data-hovercard-url=\"/BetaSu/fe-hunter/issues/1/hovercard\">XeryYue的回答</a></p>\n<h2 dir=\"auto\">答题同学须知</h2>\n<p dir=\"auto\">最佳答案由<code class=\"notranslate\">围观同学</code>的<code class=\"notranslate\">👍</code>和<a href=\"https://github.com/BetaSu\">卡颂</a>共同决定。<strong>非答题相关评论</strong>会被删除，问题相关内容讨论请在<a href=\"https://github.com/BetaSu/fe-hunter\">赏金猎人群</a>里讨论</p>\n<h2 dir=\"auto\">围观同学须知</h2>\n<p dir=\"auto\">对于你满意的答案，请不要吝惜你的<code class=\"notranslate\">👍</code>，这是评选<strong>最佳答案</strong>的标准</p>","updatedAt":"2022-03-24T12:40:05Z","upvoteCount":null,"author":{"login":"BetaSu","avatarUrl":"https://avatars.githubusercontent.com/u/15828041?u=3b08cdf9f9b49dbead9ffb020a94d925904d2b74&v=4","url":"https://github.com/BetaSu"},"category":null,"labels":{"edges":[{"node":{"name":"JS","color":"ffee58"}},{"node":{"name":"工程化","color":"ffca28"}},{"node":{"name":"webpack","color":"ff8f00"}},{"node":{"name":"场景","color":"2196f3"}}]},"comments":{"edges":[{"node":{"id":"IC_kwDOHCfdf85ADo4d","bodyHTML":"<p dir=\"auto\">使用插件：<br>\n<a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\">webpack-bundle-analyzer</a></p>\n<p dir=\"auto\">通过插件来分析引用的各个第三方包体积大小， 将一些非必要构建进去的第三方包通过 <code class=\"notranslate\">external</code> 抽离出去， 以cdn 的方式引入项目，如 lodash， dayjs，qs， 等这种纯的js库 。（避免了对这些包的构建）</p>","author":{"login":"CroatiaParanoia","avatarUrl":"https://avatars.githubusercontent.com/u/22277972?u=2d560d7626decb46436d2c27e1250d1c8f66fe37&v=4","url":"https://github.com/CroatiaParanoia"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85ADpGh","bodyHTML":"<p dir=\"auto\">接楼上回答，如果是vue-cli构建的项目，已经集成了这个插件，可以直接使用命令 <code class=\"notranslate\">vue-cli-service build --report</code> 输出包大小分析报告。<br>\n但题目要中是DEV环境，按理也是一样的。</p>","author":{"login":"OrangeSAM","avatarUrl":"https://avatars.githubusercontent.com/u/23071208?u=b6535129292703f2e499dc47379051553d0ef83c&v=4","url":"https://github.com/OrangeSAM"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85ADrmO","bodyHTML":"<p dir=\"auto\">打包用时很长</p>\n<ul dir=\"auto\">\n<li>可以结合使用 exclude ，来避免重复打包</li>\n<li>配合 使用 thread-loader 多线程打包</li>\n<li>以及webpack5.x 中提到的持久缓存属性，可以加快第二次打包速度</li>\n</ul>","author":{"login":"yaogengzhu","avatarUrl":"https://avatars.githubusercontent.com/u/42566669?u=dcded768856cdaa4518db8b8094d93f6bf51fbb2&v=4","url":"https://github.com/yaogengzhu"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85ADt-2","bodyHTML":"<p dir=\"auto\">打包用时长：换vite<br>\n打包体积大：webpack-bundle-analyzer</p>","author":{"login":"0753Ljuc","avatarUrl":"https://avatars.githubusercontent.com/u/59270826?u=e3f961f6debc1ef11b75f1c4af28b6c012c4ef34&v=4","url":"https://github.com/0753Ljuc"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85ADuXK","bodyHTML":"<ol dir=\"auto\">\n<li>在 npm build 时，一般终端都会将打包前后的大小给出来，对于不同的大小都会给出不同的颜色，一般上来黄色就是算大的了</li>\n<li>使用 webpack-bundle-analyze 进行可视化分析，文件越大所占的空间越大，可针对这写占用较大的文件进行优化</li>\n<li>使用 webpack -&gt; chainWebpack -&gt; optimization 进行代码压缩及使用其 splitChunks 进行分包处理。同时还可以针对 node_modules 下的包做 exclude</li>\n<li>对于较大的npm依赖包，可以考虑使用script cdn的方式引入，从而减少包体积</li>\n<li>项目中可能存在大量图片，对于这些图片同样适用cdn的方式，不将其打包至项目包中</li>\n</ol>","author":{"login":"jerry-lllman","avatarUrl":"https://avatars.githubusercontent.com/u/45385120?u=4ddfba34a051c4b37f7b6fdfd0c5290715e510e7&v=4","url":"https://github.com/jerry-lllman"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85ADw7d","bodyHTML":"<p dir=\"auto\">webpack的打包优化，主要就是围绕“又快又小”的目标进行，在dev环境和正式环境 追求的目标不一致，有一些配置也会不同。这里简单说几点平时会有到的一些方案：</p>\n<ol dir=\"auto\">\n<li>thread-loader 多线程提高loader的处理时间，cache-loader 加快二次打包速度</li>\n<li>使用合适的source-map 策略（dev环境，需要详细的错误定位，开发环境，则可以选择不要sourcemap，或者分离sourcemap文件，具体策略可参看官网说明）</li>\n<li>针对打包文件大的问题，可使用analyzer插件进行分析，通过extreals，include，exclude等配置进行不必要的打包</li>\n<li>同样针对bundle过大时，考虑使用code splitting方式，对代码进行异步加载import()，以及Optimization.splitChunks中配置合理的cachegroup</li>\n<li>另外顺带说句，在正式环境中使用webpack自带的压缩或者第三方压缩插件和gzip插件也是必要的</li>\n</ol>","author":{"login":"shenzhim","avatarUrl":"https://avatars.githubusercontent.com/u/12244144?u=54329039e3dca896c03b67466cfd71729abb0430&v=4","url":"https://github.com/shenzhim"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AD1RJ","bodyHTML":"<p dir=\"auto\">先说过程为什么bundle会很大,在开发项目的时候业务的叠加导致bunle大的必然的</p>\n<h3 dir=\"auto\">css部分</h3>\n<p dir=\"auto\">首先我们以css文件举例,重复的<code class=\"notranslate\">style</code>导致build的时候这些无意义的体积激增,这也就是为什么在现在<code class=\"notranslate\">css in js</code> 原子化火的理由, 采用<code class=\"notranslate\">css in js</code>或者原子化<code class=\"notranslate\">css</code>可以减少部分体积.</p>\n<h3 dir=\"auto\">静态资源部分</h3>\n<p dir=\"auto\">我们或多或少在项目中引入静态文件资源我们以图标icon举例,不是所有文件都需要打包成<code class=\"notranslate\">base64</code>,我们可以根据需要对这些文件进行处理</p>\n<h3 dir=\"auto\">代码部分</h3>\n<p dir=\"auto\">业务的拓展包括包的引入，无一例外会增加我们的包体积,对于这些<code class=\"notranslate\">bundle</code>工具而言,有<code class=\"notranslate\">tree-shaking</code>和<code class=\"notranslate\">DEC</code>，但是我们无法确保我们使用的包是否可以支持<code class=\"notranslate\">tree-shaking</code>,所以在面对一些无法<code class=\"notranslate\">tree-shaking</code>的包我们可以使用<code class=\"notranslate\">antd</code>的<code class=\"notranslate\">babel-import</code>插件去做死码消除。在编写一些代码的时候我们应该明确指明是否有副作用合理的给代码加上<code class=\"notranslate\">@pure</code> 进行标记。拥抱esm的开发方式让这些<code class=\"notranslate\">bunle</code>工具更好的工作，同时在工程上设置<code class=\"notranslate\">sideEffect</code>保证我们能充分的享受到<code class=\"notranslate\">tree-shaking</code>。</p>\n<p dir=\"auto\">答完了编码部分在源头解决了一些问题后，我们再来思考下在build完他还是那么大该怎么解决。</p>\n<ul dir=\"auto\">\n<li>合理的切割code,部分模块设置为<code class=\"notranslate\">external</code> 防止被打包到<code class=\"notranslate\">bundle</code>中,然后发布的过程采用<code class=\"notranslate\">cdn</code>进行替换。</li>\n<li>使用<code class=\"notranslate\">webpack-analyze</code>或者<code class=\"notranslate\">rollup-analyze</code> 分析工具分析具体chunk 和module。根据业务需要进行优化改造,</li>\n<li>合理思考目前应用的服务群体,到底是兼容到多少版本,这样你才能控制你的<code class=\"notranslate\">babel</code>或者<code class=\"notranslate\">swc</code>需要<code class=\"notranslate\">transform</code>的版本。</li>\n<li>关于<code class=\"notranslate\">@babel/core</code>和<code class=\"notranslate\">@babel/runtime-hepler</code>等包的依赖 ,你应该明确清楚你要如何使用,使用不当导致的体积变大也不是没有。</li>\n<li>使用<code class=\"notranslate\">treser</code>或者<code class=\"notranslate\">esbuild</code>等压缩工具进行代码压缩</li>\n<li>关于<code class=\"notranslate\">source-map</code>在生产环境下你可以关掉这样也会减少体积</li>\n</ul>\n<h3 dir=\"auto\">Dev 模式下</h3>\n<ul dir=\"auto\">\n<li>如果业务不是强依赖于<code class=\"notranslate\">webpack</code>相关，可以考虑在<code class=\"notranslate\">dev</code>模式下使用<code class=\"notranslate\">vite</code>，根据现有<code class=\"notranslate\">webpack</code>架构设计,根本无法和<code class=\"notranslate\">vite</code>相比，因为两者的工作原理不同，导致了在dev环境下差异明显,</li>\n<li>如果你强依赖于<code class=\"notranslate\">webpack</code>那么你需要增量编译合理利用缓存,其次对于<code class=\"notranslate\">require.context</code>这样的东西应该避免使用,</li>\n<li>然后<code class=\"notranslate\">ts-loader</code>这些你完全可以使用<code class=\"notranslate\">thread-loader</code>去替代他们，记住多线程构建并不是良药,进程的开销是需要代价的,你应该在本地测试得出我到底需不需要启动多进程以达到最好的效果。</li>\n<li>关于<code class=\"notranslate\">source-map</code>，选择合理的配置模式</li>\n<li>在开发环境下我们或许不需要<code class=\"notranslate\">babel</code>转换到兼容更低的版本。</li>\n</ul>\n<p dir=\"auto\">我希望各位熟知奥卡姆剃刀法则( 如无必要，勿增实体) 这样你才能在根源上解决问题</p>","author":{"login":"nonzzz","avatarUrl":"https://avatars.githubusercontent.com/u/52351095?u=6f6f36a4ced0620abe20704520835a1fdf67fef2&v=4","url":"https://github.com/nonzzz"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AD1eg","bodyHTML":"<blockquote>\n<p dir=\"auto\">先说过程为什么bundle会很大,在开发项目的时候业务的叠加导致bunle大的必然的</p>\n<h3 dir=\"auto\">css部分</h3>\n<p dir=\"auto\">首先我们以css文件举例,重复的<code class=\"notranslate\">style</code>导致build的时候这些无意义的体积激增,这也就是为什么在现在<code class=\"notranslate\">css in js</code> 原子化火的理由, 采用<code class=\"notranslate\">css in js</code>或者原子化<code class=\"notranslate\">css</code>可以减少部分体积.</p>\n<h3 dir=\"auto\">静态资源部分</h3>\n<p dir=\"auto\">我们或多或少在项目中引入静态文件资源我们以图标icon举例,不是所有文件都需要打包成<code class=\"notranslate\">base64</code>,我们可以根据需要对这些文件进行处理</p>\n<h3 dir=\"auto\">代码部分</h3>\n<p dir=\"auto\">业务的拓展包括包的引入，无一例外会增加我们的包体积,对于这些<code class=\"notranslate\">bundle</code>工具而言,有<code class=\"notranslate\">tree-shaking</code>和<code class=\"notranslate\">DEC</code>，但是我们无法确保我们使用的包是否可以支持<code class=\"notranslate\">tree-shaking</code>,所以在面对一些无法<code class=\"notranslate\">tree-shaking</code>的包我们可以使用<code class=\"notranslate\">antd</code>的<code class=\"notranslate\">babel-import</code>插件去做死码消除。在编写一些代码的时候我们应该明确指明是否有副作用合理的给代码加上<code class=\"notranslate\">@pure</code> 进行标记。拥抱esm的开发方式让这些<code class=\"notranslate\">bunle</code>工具更好的工作，同时在工程上设置<code class=\"notranslate\">sideEffect</code>保证我们能充分的享受到<code class=\"notranslate\">tree-shaking</code>。</p>\n<p dir=\"auto\">答完了编码部分在源头解决了一些问题后，我们再来思考下在build完他还是那么大该怎么解决。</p>\n<ul dir=\"auto\">\n<li>合理的切割code,部分模块设置为<code class=\"notranslate\">external</code> 防止被打包到<code class=\"notranslate\">bundle</code>中,然后发布的过程采用<code class=\"notranslate\">cdn</code>进行替换。</li>\n<li>使用<code class=\"notranslate\">webpack-analyze</code>或者<code class=\"notranslate\">rollup-analyze</code> 分析工具分析具体chunk 和module。根据业务需要进行优化改造,</li>\n<li>合理思考目前应用的服务群体,到底是兼容到多少版本,这样你才能控制你的<code class=\"notranslate\">babel</code>或者<code class=\"notranslate\">swc</code>需要<code class=\"notranslate\">transform</code>的版本。</li>\n<li>关于<code class=\"notranslate\">@babel/core</code>和<code class=\"notranslate\">@babel/runtime-hepler</code>等包的依赖 ,你应该明确清楚你要如何使用,使用不当导致的体积变大也不是没有。</li>\n<li>使用<code class=\"notranslate\">treser</code>或者<code class=\"notranslate\">esbuild</code>等压缩工具进行代码压缩</li>\n<li>关于<code class=\"notranslate\">source-map</code>在生产环境下你可以关掉这样也会减少体积</li>\n</ul>\n</blockquote>\n<p dir=\"auto\">这里额外补充，关于前面的人回答的gzip等压缩模式，按照我个人的理解,gzip这些属于服务于业务而不属于<code class=\"notranslate\">bundle</code>的范畴。它只能算工程化优化的一环和<code class=\"notranslate\">webpack</code>等bundle工具是无关的</p>","author":{"login":"nonzzz","avatarUrl":"https://avatars.githubusercontent.com/u/52351095?u=6f6f36a4ced0620abe20704520835a1fdf67fef2&v=4","url":"https://github.com/nonzzz"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AD8kc","bodyHTML":"<p dir=\"auto\">补充和实践帖<br>\n包体积分析这肯定是第一步要做的，但是要关注哪一部分</p>\n<ol dir=\"auto\">\n<li>\n<p dir=\"auto\">大包</p>\n</li>\n<li>\n<p dir=\"auto\">复用包</p>\n</li>\n<li>\n<p dir=\"auto\">冗余包<br>\n如何做？</p>\n</li>\n<li>\n<p dir=\"auto\">大包如何处理 常见的很多 <code class=\"notranslate\">lodash </code>都没做优化 ，可以用<code class=\"notranslate\"> lodash-es</code> 或者<code class=\"notranslate\"> babel-loadsh-xx</code> 转为 <code class=\"notranslate\">esm </code>引用 <code class=\"notranslate\">tree-shaking</code> 就能处理了亦或是一些三方包 这里只举例 类似于 moment 的语言包 还有highlight.js 类似的业务包 都可以做一些语言包的去除，UI库一般官方都提供对应的 <code class=\"notranslate\">babel-import</code> 配置。业务代码的话就是组件拆包 解决单包体积过大。库依赖也可以做 <code class=\"notranslate\">cdn </code>不参与构建。</p>\n</li>\n<li>\n<p dir=\"auto\">复用包 一般情况下 在<code class=\"notranslate\">analyze </code>的 <code class=\"notranslate\">report </code>中很容易发现复用模块，如果 dll 打包模式 要做合理的公共依赖抽离再配合<code class=\"notranslate\">CodeSpliting </code>做合理拆包。不是话就基于<code class=\"notranslate\">webpack5x </code>直接做拆包 完全可以替代 dll。</p>\n</li>\n<li>\n<p dir=\"auto\">冗余包就看对业务代码层面理解了，我的理解就是些无关紧要的包能自己实现就实现 不要过度依赖三方包。随着时间积累，一样能沉淀出符合自己业务线的工具包且可控</p>\n</li>\n</ol>\n<p dir=\"auto\">整体体积优化<br>\n代码压缩  简单的可选方案</p>\n<ol dir=\"auto\">\n<li><code class=\"notranslate\">webpack optimization</code> 配合 <code class=\"notranslate\">terser</code></li>\n<li><code class=\"notranslate\">swc</code></li>\n<li><code class=\"notranslate\">esbuild</code><br>\n这三种都有压缩方案 且 体积 速度 各有优劣 自己取舍</li>\n</ol>","author":{"login":"bunney","avatarUrl":"https://avatars.githubusercontent.com/u/23139406?u=473fe21999946e5496383dc13458d8e05e21e47b&v=4","url":"https://github.com/bunney"},"replies":null}},{"node":{"id":"IC_kwDOHCfdf85AEL1Q","bodyHTML":"<p dir=\"auto\">首先找到为什么体积大。webpack-bundle-analyzer 或者其他工具其实都能够很好地分析出问题点。<br>\n优化包体积的本质是优化 ttu 和 ttv。使用 webpack 的工具进行优化只能优化出普通的水平，如何业界领先需要对业务的深入理解，目标是：哪些 module 是首屏不需要的。</p>\n<p dir=\"auto\">为了达到这个目的，需要得到以下信息：</p>\n<ol dir=\"auto\">\n<li>定义你的 TTV 和 TTU；</li>\n<li>打开 performance 分析首屏做了什么，特别是注意观察哪些 chunk 是 TTV 和 TTU 必须的。</li>\n</ol>\n<p dir=\"auto\">回到 webpack-bundle-analyzer 里观察这些 chunk 的组成，观察哪些 module 是可以移除的。</p>\n<p dir=\"auto\">现在找到了可以被移除的 module，那怎么移除呢？</p>\n<p dir=\"auto\">要解决这个问题，你需要知道一个 module 为什么被引入了。</p>\n<p dir=\"auto\">在一些巨型项目里一个 module可能同时被 3~4 个module引用，这些module分布在不同的 chunk 里，这些 chunk 有可能是首屏 chunk（需要移除），有些是非首屏chunk（不需要移除），哦吼， 怎么去分析呢？</p>\n<p dir=\"auto\">好像社区里没这个解决方案，但你在使用 webpack-bundle-analyzer 前会有一个 stat.json，stat.json里有所有 module 的引用关系。</p>\n<p dir=\"auto\">有这个关系就简单了，只要解除 module 对首屏 chunk 的引用即可。</p>\n<p dir=\"auto\">接触的方法就是将 module 改成 loadable + 延迟初始化该 module。</p>\n<p dir=\"auto\">至于延迟初始化的实现方法也有很多，和这个问题无关，我就不写了~ happy hacking。</p>","author":{"login":"fulvaz","avatarUrl":"https://avatars.githubusercontent.com/u/6868351?u=65e7203021dea90867dda91e7afd734430fb9797&v=4","url":"https://github.com/fulvaz"},"replies":null}}]}}},"pageContext":{"number":1,"next":null}},
    "staticQueryHashes": ["151096407","2861350382"]}